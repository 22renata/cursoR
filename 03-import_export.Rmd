# Importando e Exportando Dados

## Data Frames

Probabelmente um dos promeiros objetos que vamos usar quando começamos usar R.
Pensa num data-frame como uma planilha de Libreoffice (o excel). Os data-frame
pode ser criaos como foi visto na seção anterior. O principal, é que temos varias
funções para ler data-frames no R, entre elas

- read.csv
- read.csv2
- read.table

Agora vamos a ler dados do repositorio usando read.table, mas primeiro vamos lembrar
que se tu precisar ver a ajuda da função, tem que escrever no R `?read.table`.
Então, agora vamos ver os argumentos da função:

```{r}
args(read.table)
```

Aqui vem-se os valores default dos argumentos da função `read.table`. O terceiro
argumento é sep, com valores por default = "". 


```{r}
df <- read.table("dados/NOXIPEN2014.txt")
```

Agora vamos usar a funções `head` and `tail` para ver as primeiras e as ultimas
6 linhas do data-frame.

```{r}
head(df)
tail(df)
```


Agora vamos ler os mesmos dados com outro formato e testar e read.table funciona
do mesmo jeito
```{r eval = FALSE}
df2 <- read.table("dados/NOXIPEN2014v2.txt")
# Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : 
# linha 1 não tinha 6 elementos
```

Vemos a mensagem de error, mas o que quer dizer.

**Se tu recever um banco de dados tipo .txt e quer abrir no R... ABRE ELE COM BLOCO DE NOTAS PRIMEIRO!!!**

O primeiro arquivo:

```{r echo = FALSE}
knitr::include_graphics("figuras/f1.png")
```

O segundo arquivo é:

```{r echo = FALSE}
knitr::include_graphics("figuras/f2.png")
```


qual é a diferença?


Como vemos o segundo arquivo tem separação de ";", entao, temos que lero arquivo
assim:

```{r}
df2 <- read.table("dados/NOXIPEN2014v2.txt", sep = ";")
head(df2)
tail(df2)
```

**Qua dificultades tu já enfrentou importando dados?**

## BASE
  
### Exportando texto com `write.table`

Exportar é bem facil, mas se sabemos os argumentos das funções, vai ser
mais eficiente ainda. Vamos `write.table`

```{r}
args(write.table)
```

Se temos um data-frame com colunas de classe character, `quote = TRUE`
quer dizer que o arquivo de texto resultante vai ter aspas nas colunas
de caracter.

`sep` é como vão ser separadas as colunas. Se tu quer abrir o arquivo com
Excel, poderia separar com ",", ";", " ", "\t"... Depende como tu quer.

eol quer dizer _end of line_, e é para ver a forma de colocar o "end of 
line"

**row.names**.. esta  TRUE mas SEMPRE SEMPRE SEMPRE COLOCA:

**row.names = FALSE**. Se não, R vai adiiconar uma coluna com os indices
das linhas....

col.names se tu quer o nome nas colunas...

**PRATICA!**

### Exportando objetos com `save`


```{r}
args(save)
```

`save` salva o objeto com a extensão .rda. Para carregar de volta o
objeto, tem que ser feito com a função `load`


```{r}
args(load)
```

O que pode ser ruim, porque as vezes tu esqueceu o nome do objeto no
ambiente de R. Por exemplo, tu salvou o arquivo

```{r eval=FALSE}
save(frenteFria, file = "FrenteQuente.rda")
```


logo tu carrega

```{r eval = FALSE}
load("FrenteQuente.rda")
```

acreditando que vai ter tua frente quente, mas o nome do objeto no 
ambiente de R é frenteDria... então, tem que ficar de olho, e como somos
imperfeito, vai dar merda....

O melhor da função é que permite salvar com tipos de compressão, por 
exemplo compress = "xz".

### Exportando objetos com `saveRDS`

Esta é uma das minhas funçoes favoritas no R

```{r}
args(saveRDS)
```

e

```{r}
args(readRDS)
```


Tu consegue salvar o objeto R de forma serializada e compactada
com o argumento `compress` mas o melhor é quando vai chamar o objeto 
de volta ao R. Agora tu usa o `readRDS` e coloca o nome que tu
quiser.

```{r eval = FALSE}
saveRDS(FrenteQuente, "FrenteQuente.rds")
```

```{r eval = FALSE}
frenteQ <- readRDS("FremteQuente.rds")
```


### Processando nossa data-frame {#processing_dfs}

Tem numeroas formas e pacotes para ordenar, arrangiar (Arrange), mutar e cambiar
as data-frames. As mais conhecidas são provablemente do universe *tidyverse* com 
o famoso pacote _dplyr_. Mas, nesta curso vamos focar em **base**.

Vamos então revisar a classe de cada columna do nosso data-frame com a função
`sapply`, apresentada em outro capitulo, mas se quiser, da uma olhada em `?sapply`.

```{r}
sapply(df, class)
```

Quando nos trabalhamos com series de tempo, é importante ter a variabel de tempo
reconhecida como "tempo", especificamente como classe "POSIXct". Mas, a classe de
Data é "factor" e de Hora tambem "factor", o que é ruim. Então, vamos criar uma
variabel de tempo mais standard com formato `r Sys.time()`.

Para isso temos que grudar as variabel Data e Hora. Faremios isso numa nova
varaibel chamada tempo_char, adicionando ela diretamente no `df` com o cifrão 
DOLLAR $. O grude pode ser feito com as funções `paste` ou `paste0`.

```{r}
df$tempo_char <- paste(df$Data, df$Hora)
head(df$tempo_char)
class(df$tempo_char)
```

Esta melhorando mas ainda tem clase `r class(df$tempo_char)`.

Para convertir a nossa classe POSIXct podemos usar a função `as.POSIXct` (olha 
`as.POSIXct`). Seus argumentos são:

```{r}
args(as.POSIXct)
```


Então, vamos criar outra variabel tempo o formato POSIXct

```{r}
df$tempo <- as.POSIXct(x = df$tempo_char, tz = "Americas/Sao_Paulo", 
                       format = "%d/%m/%Y %H:%M")
head(df$tempo)
class(df$tempo)
```

Agora, vamos a extraer os dias da semana do tempo, mes e dia juliano:

```{r}
df$weekdays <- format(df$tempo, "%A")
head(df$weekdays)
df$mes <- format(df$tempo, "%B")
head(df$mes)
df$diajuliano <- julian(df$tempo)
head(df$diajuliano)

df$ano <- format(df$tempo, "%Y")
```

### aggregate

Vamos a carregar a nossa data.frame. Primero uma olhada

```{r}
head(df)
```

Poderiamos calcular a media horaria por dia da semana. Então:

```{r}
dff <- aggregate(df$MediaHoraria, by = list(df$weekdays), sum, na.rm = T)
dff
names(dff) <- c("dias", "MediaHoraria")
```

```{r}
dff$sd <- aggregate(df$MediaHoraria, 
                    by = list(df$weekdays), 
                    sum, na.rm = T)$x
dff
```


### subset

Como poderiamos escolher só o mes de janeiro??

```{r}
#[     LINHAS    ,  COLUNAS   ]
head(df[df$mes == "janeiro", ]) #TODAS AS COLUNAS
```


Mes janeiro pero solo o valor mediahoraria, que retorna um vetor numerico

```{r}
names(df)
head(df[df$mes == "janeiro", 10]) 
head(df[df$mes == "janeiro", "MediaHoraria"])
class(df[df$mes == "janeiro", "MediaHoraria"])
```

Mas vamos salvar o nosso "df"

```{r}
saveRDS(df, "dados/df.rds")
```


### data.table e mais

data.table é um pacote que apresenta a classe `data.table`, que é como uma versão
melhorada da classe `data-frame` O termo especifico é que `data-table` tem 
herencia (inherits) da classe `data.frame`

Vamos ver como funciona data.table lendo o dois arquivos e comparar quanto tempo
demoram cada um.

```{r}
df1 <- print(system.time(read.table("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014.txt", h = T)))
```

```{r}
library(data.table)
df2 <- print(system.time(fread("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014.txt", h = T)))

```



olha que estamos usando a função `fread`.



## Tidyverse

Um método mais recente (e muito interessante!) de tratar data frames é usando os pacotes dentro do [Tidyverse](https://www.tidyverse.org/).  
Usando diversas funções dos pacotes **readr**, **tidyr** e **dplyr**, por exemplo, é possível ler e processar dados de uma maneira mais *user-friendly* devido à sintaxe das funções e de como elas podem ser usadas em conjunto.  
Note que muitas das funções usadas abaixo podem ser encontradas em Base ou em outros pacotes.

### Importando dados

Todas as funções de leitura possuem a mesma estrutura:  

```{r, eval = F}
read_*(arquivo, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c("", "NA"),
quoted_na = TRUE, comment = "", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000,
n_max), progress = interactive())
```

*Dica: Quando a descrição de uma função mostra os argumentos já definidos (`col_names = TRUE`), isso significa que esses são os valores padrão e que você não precisa escrever os argumentos se não quiser mudá-los*  

Assim, todas as funções de leitura só precisam do nome do arquivo!  

Então como ler diferentes arquivos? Usando diferentes funções.

- `read_csv` lê arquivos .csv **separados por $,$**  
- `read_csv2` lê arquivos .csv **separados por $;$**  
- `read_delim` lê arquivos **com outros separadores** (definidos com o argumento `delim`)  
- `read_fwf` lê arquivos **com delimitação fixa** (definidos com o argumento `col_positions`)  
- `read_xl` lê arquivos **Excel** (.xls e .xlsx)  

### Leitura `%>%` Processamento

Existem funções de leitura e modificação de data frames. Muitas vezes, você precisa lidar com dados "brutos" e que precisam de um certo processamento antes de serem utilizados em cálculos e gráficos. Isso exige no mínimo duas funções em duas linhas de código (uma para ler e outra para modificar), mas em geral esse processo precisa de bem mais do que isso.  

O operador `%>%` (chamada de *pipe*) está dentro do pacote magnittr (dentro do Tidyverse) e é muito útil nesse processo! ([Leia um pouco sobre ele aqui](https://www.datacamp.com/community/tutorials/pipe-r-tutorial))  

Como ele funciona?  

> variável %>% função1(., faz a modificação 1) %>% função2(., faz a modificação 2) %>% ... funçãon(., faz a modificação n)

O ponto (.) acima indica que a função será aplicada na versão da variável que chega nela.  
Em notação matemática, podemos dizer que $x \ \ \%>\% \ \ f(y) = f(x,y)$.  
Por exemplo, observe o código abaixo:

```{r, message=F}
library("tidyverse")

seq(1, 10) %>% order(., decreasing = T) %>% paste(., "vezes")
```

O vetor (que não precisa necessariamente ser definido como uma variável) é primeiro ordenado de forma decrescente e, a partir dessa modificação, é transformado em um vetor de caracteres ao colar a string "vezes" a ele.  

Uma forma de fazer isso sem usar `%>%` seria:  

```{r}
paste(order(seq(1, 10), decreasing = T), "vezes")
```

<span style="color:blue">**Pergunta**: Na sua opinião, qual é o código mais fácil e rápido de ser entendido?</span>  

Como isso pode ser aplicado a data frames?



## Outros Tipos de Dados
  
### NetCDF

O NetCDF (Network Common Data Form) é um conjunto de bibliotecas de software e formatos de dados independentes de máquina e autodescritivos com suporte para criação, acesso e compartilhamento de dados científicos orientados a matrizes. Arquivos NetCDF (criado por essa biblioteca ou por programas que utilizam essa biblioteca) são arquivos compostos por dados, atributos e metadados.

O pacote `ncdf4` pode ser usado para acessar a essa biblioteca, os comandos abaixo instalam e carregam esse pacote:
```{r  eval = TRUE}
#install.packages("ncdf4")  # instala o pacote
install.packages("eixport") # pacote onde estão os dados que iremos utilizar
library("ncdf4")            # carrega os pacotes
library("eixport")          # carrega os pacotes
nc_version()                # que retorna a versão da biblioteca
```
Um exemplo de NetCDF:
```{r}
wrfinput <- paste0(system.file("extdata", package = "eixport"), "/wrfinput_d01")
```

Abre o arquivo .nc  

```{r eval = TRUE}
wrf <- ncdf4::nc_open(wrfinput)
print(wrf)
```


O objeto `wrf` contém algumas informações sobre o conteúdo do arquivo, com um `print(wrf)` ou simplesmente `wrf` visualizamos o conteúdo do arquivo:
```{r  eval = TRUE}
class(wrf)
# fazer print(wrf)
```
que mostra o nome do arquivo (e versão da biblioteca usada para criar), número de variáveis (92 no arquivo de exemplo), uma descrição de cada variável (incluindo atributos) as dimensões (13 para esse arquivo) e os atributos globais.

Agora vamos abrir alguma variável:
```{r eval = TRUE}
names(wrf$var)                # print no nome de cada variavel
#Times <- ncdf4::ncvar_get(wrf, varid = "Times")  # escolho você picachu
#class(Times)
```

Como o NetCDF é organizado para guardar matrizes (arrays), só sabemos que a variável `ST` é um array

```{r eval = TRUE}
ncatt_get(wrf,"Times", verbose = T) # ou ncatt_get(wrf,"TT",verbose = T)
```

praticamente a mesma informação do outro caso:
```
float TT[west_east,south_north,num_metgrid_levels,Time]   
FieldType: 104
MemoryOrder: XYZ
units: K
description: Temperature
stagger: M
sr_x: 1
sr_y: 1
```

como temos apenas 1 tempo essa dimensão é desconsiderada para simplificar.

A latitude de cada ponto de grade, assim como longitude níveis e tempo podem ser extraídas:

```{r eval = TRUE}
lat  <- ncvar_get(wrf, "XLAT")
lon  <- ncvar_get(wrf, "XLONG")
time <- ncvar_get(wrf, "Times")
```
O metadado de Longitude:
```
float XLONG[west_east,south_north,Time]   
FieldType: 104
MemoryOrder: XY 
units: degrees longitude
description: Longitude on mass grid
stagger: M
sr_x: 1
sr_y: 1
```
Latitude:
```
float XLAT[west_east,south_north,Time]   
FieldType: 104
MemoryOrder: XY 
units: degrees latitude
description: Latitude on mass grid
stagger: M
sr_x: 1
sr_y: 1
```
e a altura:
```
float GHT[west_east,south_north,num_metgrid_levels,Time]   
FieldType: 104
MemoryOrder: XYZ
units: m
description: Height
stagger: M
sr_x: 1
sr_y: 1
```
Da mesma forma com que podemos acessar variáveis e atributos com `ncvar_get` e `ncatt_get`, podemos modificar estes valores com `ncvar_put` e `ncatt_put`. Outras operações como renomear (`ncvar_rename`) e trocar o valor de missval (`ncvar_change_missval`) também estão disponíveis.

*DICA*: `ncatt_get` e `ncatt_put` acessam e alteram os atributos de váriaveis e também atributos globais do NetCDF usando o argumento `varid=0`.

Para salvar as alterações e/ou liberar o acesso ao arquivo use a função `nc_close` (ou a função `nc_sync` que sincroniza o NetCDF mas não fecha a conexão com o arquivo).

```{r eval = TRUE}
nc_close(wrf) # ou nc_sync(wrf)
```

Novas dimensões e também novas variáveis podem ser criadas com `ncvar_def` e `ncvar_add` em um arquivo aberto com permissão de leitura, como por exemplo:
```{r eval=FALSE}
wrf     <- nc_open("dados/met_em.d03.2016-01-10.nc", write = TRUE)
extrema <- ncvar_def(name = "Tex",
                     units = "K",
                     dim = list(wrf$dim$west_east,
                                wrf$dim$south_north,
                                wrf$dim$Time),
                     missval = -999,
                     longname = "temperatura extrema")
ncvar_add(wrf, extrema)
names(wrf$var)
nc_close(wrf)
```
Se esse arquivo for aberto novamente vai conter 93 variáveis junto com a variável `Tex` da forma que definimos, caso queria os mesmos atributos que as demais é só usar a função `ncatt_get` na variável.

```{r eval = FALSE}
wrf     <- ncdf4::nc_open("dados/met_em.d03.2016-01-10.nc", write=T)
print(wrf)[1:10]
```

O pacote possue ainda funções mais específicas para a criação de arquivos em NetCDF como `nc_create`, funções que definem dimenções como `ncdim_def` e funções para colocar e tirar o arquivo de modo de definição `nc_redef` e `nc_enddef`.

*DICA*: o NetCDF no R funciona de forma parecida com ouma lista ou data frame, podemos "ver" ou selecionar suas sub-partes (sub-sub-partes...) com "$" e TAB.

### Dados Binários

**Ler dados binários no R**

Em meteorologia, frequentemente os dados estão em formato binário. A maior "dificuldade" em ler estes dados está em conhecer como eles foram gerados. 

Repare que a função `readBin` requer vários argumentos para ler estes dados da forma correta:

```{r}
args(readBin)
```

Neste curso, o arquivo binário que vamos abrir como exemplo contém dados de temperatura de brilho obtidas com o satélite GOES-13 (informações em: https://disc.gsfc.nasa.gov/datasets/GPM_MERGIR_1/summary).

Lembrem-se de baixar o dado em: https://github.com/iagdevs/cursoR/tree/master/dados

```{r}
# Ler o arquivo binário
l1 <- readBin("dados/gs.140422.1900g.ch4", 
              what="int", 
              n = 1349*1613,
              size = 2)
class(l1)
```

Note que o argumento `endian` por default é `.Platform$endian`. Se rodarmos `.Platform$endian` no R obteremos a ordenação dos bytes ("big" ou "little") utilizada pela plataforma que estamos usando.  

Uma forma rápida para verificarmos os nossos dados é gráfica. Logo, que tal um plot?
```{r}
l2 <- matrix(l1, ncol=1613, nrow=1349)
class(l2)
# Vamos chamar o pacote cptcity para selecionar facilmente uma paleta de cores legal.
library(cptcity)   
image(l2,
      col = cpt(find_cpt("sat")[8]),
      main = "Temperatura de brilho") 
```

Tem algo estranho com esta imagem. O que é? (valendo um sticker).

```{r message=FALSE, warning=FALSE}
library(raster, quietly = TRUE)
l3 <- raster(t(l2[1:1349,1:1613]),
                     xmn=-82.00,
                     ymn=-44.96,
                     xmx=-82.0  + (0.03593245*1349), 
                     ymx=-44.96 + (0.03593245*1613),
                     crs = CRS("+init=epsg:4326"))
class(l3)
```
O capítulo geoespacial será visto no final deste curso. Porém, nesta etapa vamos usar o pacote `raster` somente para analisar se os dados binários foram lidos corretamente.
```{r}
sp::spplot(((l3 + 75)/100)-273, # Estas correções são necessárias. Veja: http://www.cpc.ncep.noaa.gov/products/global_precip/html/README
           col.regions = cpt(find_cpt("sat")[8]),
           at = seq(-80,0,1),
           main = "Temperatura de brilho (ºC)") 
```

**Escrever dados binários no R**

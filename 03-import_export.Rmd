# Importando e exportando dados em R

## Revendo Data frames

Como vimos anteriormente, na maioria dos casos, iremos usar data frames par lidar com dados em R, sendo assim, podemos utilizar os seguintes modos de leitura: 

- read.csv
- read.csv2
- read.table

Vamos ler alguns dados usando read.table, para saber o que a função faz, use `?read.table`. Os argumentos da função são:

```{r}
args(read.table)
```

O terceiro argumento é sep, com valores por default = "". Esse argumento indica para o R qual o tipo de separador utilizado entre as colunas dos dados.

```{r}
df <- read.table("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014.txt")
```

Lembre-se que as funções head e tail permitem que você veja as primeiras ou últimas linhas do data frame.

```{r}
head(df)
tail(df)
```

O que acontece se tentarmos ler os mesmo dados utilizando a função read.table?

```{r eval = FALSE}
df2 <- read.table("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014v2.txt")
# Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : 
# linha 1 não tinha 6 elementos
```

Apareceu uma mensagem de erro, você saberia dizer o porquê?

**Caso você trabalhe com algum banco de dados em formato .txt e quiser abrir no R... Abra-os no bloco de notas primeiro**

Vamos dar uma olhada em alguns dados, o primeiro tem uma cara assim:

```{r echo = FALSE}
knitr::include_graphics("figuras/f1.png")
```

Já o segundo arquivo é assim:

```{r echo = FALSE}
knitr::include_graphics("figuras/f2.png")
```

Você notou a diferença? Como vimos anteriormente, para importar os dados no R é super importante que você especifique o tipo de separador utilizado, como o segundo arquivo tem separação de ";", precisamos espercificar o argumento `sep` na hora de usar o comando `read.table`:

```{r}
df2 <- read.table("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014v2.txt", sep = ";")
head(df2)
tail(df2)
```

Além desses comandos, vocês também pode utilizar a opção **Import Dataset** do Rstudio, permitindo que você tenha um "preview" dos dados, como no excel, mas melhor!

Para mais informações sobre importar dados no R, dê uma olha nesse [webnário](https://www.rstudio.com/resources/webinars/importing-data-into-r/)

## Exportando texto com `write.table`

Exportar é bem facil. Vamos dar uma olhada nos argumentos da função `write.table`:

```{r}
args(write.table)
```

Se temos um data-frame com colunas de classe character, `quote = TRUE` quer dizer que o arquivo de texto resultante vai ter aspas nas colunas de caractere. Novamente, o argumento `sep` indica como podemos separar as colunas. Se você quiser abrir esses dados no excel, uma boa opção é utilizar os separadores ","/";"/" "/"\t", sendo o último o separador que indica o espaçamento criado pela tecla TAB.

Já o argumento `eol` quer dizer _end of line_, e é uma forma de dizer ao R que a linha acaba ali. 
Por padrão, a opção `row.names` vem com a opção TRUE, mas sempre coloque a opção FALSE, caso contrário, será adicionada uma coluna com os índices das linhas. O argumento `col.names` indica se você quer nomear as suas colunas, o que é sempre uma boa ideia.

```{block2}
**Exercício:** Usando o conjunto de dados `mtcars` da base do R, vamos exportá-lo de uma forma que ele possa ser lido em algum Excel genérico. Não esqueça de usar o que foi ensinado acima.
```


## Exportando objetos com `save`

Podemos salvar objetos do R com o comando `save`, ele permite que você recarregue o objeto mais tarde.

```{r}
args(save)
```

Essa função salva o objeto com a extensão .rda sendo que para carregá-lo de volta usamos a função `load`

```{r}
args(load)
```

Muito cuidado ao utilizar esse comando, pois podemos cometer alguns delizes, como trocar o nome do objeto. Veja esse exemplo abaixo:

```{r eval=FALSE}
#Primeiro vamos ler os dados do dia 01/06/2016 para uma estação automática do INMET de Paracatu:
paracatu <- read.csv(file = "./dados/paracatu.csv", sep = ",") #lendo como csv

# Vamos dizer que queremos salvar apenas a coluna correspondente à temperatura máxima horária:
paracatu_temp <- paracatu$temp_max  

#Agora vamos salvar o objeto do tipo numeric com o nome especificado:
save(paracatu_temp, file = "Temp_max.rda")
```

Passado um tempo, queremos acessar de volta esse objeto, mas não lembramos se salvamos a temperatura máxima ou mínima, vamos confiar que foi a mínima:

```{r eval = FALSE}
load("Temp_min.rda")
```

E assim descobrimos que não era... O que nos ensina a sempre guardar na memória quais variáveis que salvamos no ambiente R. O bom dessa função é que ela permite salvar com tipos de compressão, por 
exemplo compress = "xz".

## Exportando objetos com `saveRDS`

Esta é uma das minhas funçoes favoritas no R, veja só o porquê:

```{r eval = FALSE}
saveRDS(paracatu_temp, "Temperatura.rds")
```

```{r eval = FALSE}
frenteQ <- readRDS("Temperatura.rds")
```

Você pode salvar seu objeto R de forma serializada e compactada
com o argumento `compress` e na hora de chamar o objeto de volta é só usar `readRDS` e colocar o nome que você quiser.

## Processando nossa data-frame {#processing_dfs}

Existem inúmeros pacotes para organizar (Arrange) e modificar data frames. As mais conhecidas são provavelmente do universe *tidyverse* como o famoso pacote _dplyr_. Mas, neste curso vamos focar no **base**.

Vamos então revisar a classe de cada coluna do nosso data-frame com a função
`sapply`, que será revisada em putro capítuo, mas lembre, qualquer dúvida é só usar `?sapply`.

```{r}
sapply(df, class)
```

Quando trabalhamos com séries temporais, é importante ter a variável tempo
reconhecida como "tempo", especificamente como classe "POSIXct", porém, a calsse do tipo Data é "factor" assim como a Hora, o que pode ser ruim. Então, vamos criar uma variável de tempo mais padronizada com o formato `r Sys.time()`.

Para isso temos que juntar as variáveis Data e Hora. Faremos isso numa nova
varável chamada "tempo_char"", adicionando-a diretamente no data frame com o cifrão 
DOLLAR "$". Podemos fazer isso com as funções `paste` ou `paste0`.

```{r}
df$tempo_char <- paste(df$Data, df$Hora)
head(df$tempo_char)
class(df$tempo_char)
```

Melhorou, mas ainda tem clase `r class(df$tempo_char)`.

Para converter a nossa classe para POSIXct podemos usar a função `as.POSIXct` (olhe  
`?as.POSIXct`). Seus argumentos são:

```{r}
args(as.POSIXct)
```


Então, vamos criar outra variável tempo o formato POSIXct:

```{r}
df$tempo <- as.POSIXct(x = df$tempo_char, tz = "Americas/Sao_Paulo", 
                       format = "%d/%m/%Y %H:%M")
head(df$tempo)
class(df$tempo)
```

Agora, vamos a extrair os dias da semana do tempo, mes e dia juliano:

```{r}
df$weekdays <- format(df$tempo, "%A")
head(df$weekdays)
df$mes <- format(df$tempo, "%B")
head(df$mes)
df$diajuliano <- julian(df$tempo)
head(df$diajuliano)

df$ano <- format(df$tempo, "%Y")
```

Pronto! Agora temos o tempo no formato que desejamos.

## Aggregate

Vamos a carregar o nosso data frame e daruma olhada nele:

```{r}
head(df)
```

Podemos calcular a média horaria por dia da semana:

```{r}
dff <- aggregate(df$MediaHoraria, by = list(df$weekdays), sum, na.rm = T)
dff
names(dff) <- c("dias", "MediaHoraria")
```

```{r}
dff$sd <- aggregate(df$MediaHoraria, 
                    by = list(df$weekdays), 
                    sum, na.rm = T)$x
dff
```


## Subset

Como podemos escolher só o mês de janeiro??

```{r}
#[     LINHAS    ,  COLUNAS   ]
head(df[df$mes == "janeiro", ]) #TODAS AS COLUNAS
```

Só que agora temos só a média horária para esse mês, que retorna um vetor numérico:

```{r}
names(df)
head(df[df$mes == "janeiro", 10]) 
head(df[df$mes == "janeiro", "MediaHoraria"])
class(df[df$mes == "janeiro", "MediaHoraria"])
```

Dessa forma, vamos salvar nosso data frame:

```{r}
saveRDS(df, "df.rds")
```

## Data.table, read_xl e mais

O data.table é um pacote que apresenta a classe `data.table`, que é como uma versão
melhorada da classe `data-frame` O termo especifico é que `data-table` tem 
um "parentesco" (inherits) com a classe `data.frame`

Vamos ver como funciona data.table lendo o dois arquivos e comparar quanto tempo
demora cada um.

```{r}
df1 <- print(system.time(read.table("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014.txt", h = T)))
```

```{r}
library(data.table)
df2 <- print(system.time(fread("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014.txt", h = T)))

```

Para isso usamos a função `fread`.

Já o read_xl é mais uma função do universo tidyverse que permite importar excel no R, diretamente e de forma eficiente.

## NetCDF

O NetCDF (Network Common Data Form) é um conjunto de bibliotecas de software e formatos de dados independentes de máquina e autodescritivos com suporte para criação, acesso e compartilhamento de dados científicos orientados a matrizes. Arquivos NetCDF (criado por essa biblioteca ou por programas que utilizam essa biblioteca) são arquivos compostos por dados, atributos e metadados.

O pacote `ncdf4` pode ser usado para acessar a essa biblioteca, os comandos abaixo instalam e carregam esse pacote:

```{r }
#install.packages("ncdf4") # instala o pacote
library("ncdf4")          # carrega o pacote
nc_version()              # que retorna a versão da biblioteca
```

Um exmplo de NetCDF:

```{r}
download.file("https://github.com/ibarraespinosa/cursoR/raw/master/dados/met_em.d03.2016-01-10.nc", destfile = "~/met_em.d03.2016-01-10.nc")
```

```{r}
wrf <- ncdf4::nc_open("./dados/met_em.d03.2016-01-10.nc")
```

O objeto `wrf` contém algumas informações sobre o conteúdo do arquivo, com um `print(wrf)` ou simplesmente `wrf` visualizamos o conteúdo do arquivo:

```{r}
class(wrf)
wrf
```

Isso mostra o nome do arquivo (e versão da biblioteca usada para criar), número de variáveis (92 no arquivo de exemplo), uma descrição de cada variável (incluindo atributos) as dimensões (13 para esse arquivo) e os atributos globais.

Agora vamos abrir alguma variável:

```{r}
names(wrf$var)                # print no nome de cada variavel
TEMP <- ncdf4::ncvar_get(wrf, "TT")  # escolho você picachu
class(TEMP)
```

Como o NetCDF é organizado para guardar matrizes (arrays), só sabemos que a variável `ST` é um array

```{r}
ncatt_get(wrf,"TT") # ou ncatt_get(wrf,"TT",verbose = T)
dim(TEMP)
```

praticamente a mesma informação do print anterior:
```
float TT[west_east,south_north,num_metgrid_levels,Time]   
FieldType: 104
MemoryOrder: XYZ
units: K
description: Temperature
stagger: M
sr_x: 1
sr_y: 1
```

como temos apenas 1 tempo essa dimensão é desconsiderada para simplificar.

A latitude de cada ponto de grade, assim como longitude níveis e tempo podem ser extraídas:

```{r}
lat  <- ncvar_get(wrf, "XLAT_M")
lon  <- ncvar_get(wrf, "XLONG_M")
time <- ncvar_get(wrf, "Times")
```
O metadado de Longitude:
```
float XLONG_M[west_east,south_north,Time]   
FieldType: 104
MemoryOrder: XY 
units: degrees longitude
description: Longitude on mass grid
stagger: M
sr_x: 1
sr_y: 1
```
Latitude:
```
float XLAT_M[west_east,south_north,Time]   
FieldType: 104
MemoryOrder: XY 
units: degrees latitude
description: Latitude on mass grid
stagger: M
sr_x: 1
sr_y: 1
```
e a altura:
```
float GHT[west_east,south_north,num_metgrid_levels,Time]   
FieldType: 104
MemoryOrder: XYZ
units: m
description: Height
stagger: M
sr_x: 1
sr_y: 1
```
Da mesma forma com que podemos acessar variáveis e atributos com `ncvar_get` e `ncatt_get`, podemos modificar estes valores com `ncvar_put` e `ncatt_put`. Outras operações como renomear (`ncvar_rename`) e trocar o valor de missval (`ncvar_change_missval`) também estão disponíveis.

*DICA*: `ncatt_get` e `ncatt_put` acessam e alteram os atributos de váriaveis e também atributos globais do NetCDF usando o argumento `varid=0`.

Para salvar as alterações e/ou liberar o acesso ao arquivo use a função `nc_close` (ou a função `nc_sync` que sincroniza o NetCDF mas não fecha a conexão com o arquivo).

```{r}
nc_close(wrf) # ou nc_sync(wrf)
```

Novas dimensões e também novas variáveis podem ser criadas com `ncvar_def` e `ncvar_add` em um arquivo aberto com permissão de leitura, como por exemplo:
```{r eval=FALSE}
wrf     <- nc_open("~/met_em.d03.2016-01-10.nc", write=TRUE)
extrema <- ncvar_def(name = "Tex",
                     units = "K",
                     dim = list(wrf$dim$west_east,
                                wrf$dim$south_north,
                                wrf$dim$Time),
                     missval = -999,
                     longname = "temperatura extrema")
ncvar_add(wrf, extrema)
names(wrf$var)
nc_close(wrf)
```
Se esse arquivo for aberto novamente vai conter 93 variáveis junto com a variável `Tex` da forma que definimos, caso queria os mesmos atributos que as demais é só usar a função `ncatt_get` na variável.

```{r}
wrf     <- nc_open("~/met_em.d03.2016-01-10.nc",write=T)
print(wrf)
```
O pacote possue ainda funções mais específicas para a criação de arquivos em NetCDF como `nc_create`, funções que definem dimenções como `ncdim_def` e funções para colocar e tirar o arquivo de modo de definição `nc_redef` e `nc_enddef`.

*DICA*: o NetCDF no R funciona de forma parecida com ouma lista ou data frame, podemos "ver" ou selecionar suas sub-partes (sub-sub-partes...) com "$" e TAB.



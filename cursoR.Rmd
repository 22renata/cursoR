--- 
title: "Curso de R para Meteorologia IAG/USP"
author: "Sergio Ibarra-Espinosa,\n Amanda Rehbein,\n Daniel Schuch,\n Camila Lopes,\n Isabela Siqueira,\n e possivelmente outros (você está convidado para colaborar)"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: iagdevs/cursoR
description: "Este é um curso de R para Meteorologia. O curso tenta ser abrangente, desde interessados sem formação, passando por graduação e pós-graduação"
---

# Pré-Requisitos {#primero}

## Sistema Operacional

Antes de instalar o R na sua plataforma de interesse, verifique se há recomendações abaixo:

**Windows**  
A princípio não há pré-requisitos! Caso fique entusiasmado com o R e queira desenvolver os próprios pacotes, instale o Rtools https://cran.r-project.org/bin/windows/Rtools/

Instale `NetCDF`, `GDAL`, `GEOS`, `udunits` e `PROJ`
  
**MacOS**  

```{bash eval = FALSE}
brew unlink gdal
brew tap osgeo/osgeo4mac && brew tap --repair
brew install proj
brew install geos
brew install udunits
brew install gdal2 --with-armadillo --with-complete --with-libkml --with-unsupported
brew link --force gdal2
```
(Veja como instalar NetCDF no MacOS)  
  
**Linux (Ubuntu e derivados)**

```{bash eval = FALSE}
sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable --yes
sudo apt-get --yes --force-yes update -qq
# units/udunits2 dependency:
sudo apt-get install --yes libudunits2-dev
# sf dependencies:
sudo apt-get install --yes libproj-dev libgeos-dev libgdal-dev libnetcdf-dev  netcdf-bin gdal-bin
```


## Pacotes usados neste curso

Para fazer este curso instale os seguintes pacotes como indicado:

```{r eval = FALSE}
check.packages <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg))
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

# Usage example
packages <- c("devtools", "tidyverse", "reshape2", "sf",
              "maptools", "mapview", "fields", "raster",
              "sp", "rgdal", "ncdf4", "data.table",
              "openair", "cptcity")
check.packages(packages)
devtools::install_github("atmoschem/veinreport")
```
Fonte: https://gist.github.com/smithdanielle/9913897

Descrição de alguns desses pacotes:

* [devtools](https://CRAN.R-project.org/package=devtools) permite a instalação de versões de desenvolvimento de pacotes de diferentes repositórios
* [tidyverse](https://github.com/tidyverse) é o universo de pacotes do Hadley
Wickham para tratamento e visualização de dados  
    + Se você quiser plotar os objetos espaciais sf com o pacote [ggplot2](http://ggplot2.tidyverse.org/) (que faz parte do tidyverse), ele precisa ser instalado usando o devtools (`devtools::install_github("tidyverse/ggplot2")`), pois a função [geom_sf](https://www.isgeomsfinggplot2yet.site/) ainda não está disponível na versão oficial
* [sf](https://github.com/r-spatial/sf), [mapview](https://github.com/r-spatial/mapview), raster, sp, rgdal, maptools e fields tratam dados espaciais. Lembre-se que os objetos em Meteorologia são espaço-temporais
* ncdf4 é um pacote para manipular arquivos NetCDF
* [openair](http://davidcarslaw.github.io/openair/) é um pacote para
trabalhar com dados de qualidade do ar e Meteorologia
* [cptcity](https://ibarraespinosa.github.io/cptcity/) é um pacote que tem 7140 paletas de cores do arquivo web [cpt-city](http://soliton.vm.bytemark.co.uk/pub/cpt-city/index.html)
  
Preste atenção na instalação dos pacotes pois eles podem precisar de dependências do sistema.

```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```
## Dados usados neste curso
Os exemplos mostrados neste curso usarão os dados que vocês podem baixar em:
https://github.com/iagdevs/cursoR/tree/master/dados

## Colaborar

A melhor forma de colaboração é com [*pull requests* no repositório do curso](https://github.com/iagdevs/cursoR/pull/new/master). Aplique o [Guia de Estilo de R do Google](https://google.github.io/styleguide/Rguide.xml) ou o formato [formatR](https://yihui.name/formatr/). Em poucas palavras, lembre que seu código vai ser lido por seres humanos. É possível editar qualquer página usando um dos botões acima.

## Compartilhar dados

Se você conhece alguma fonte de dados para deixar este curso mais legal, edite este arquivo e faça um *pull request*.
  
1. NCEP: ftp://nomads.ncdc.noaa.gov/GFS/analysis_only/
2. ...
3. ...


<!--chapter:end:index.Rmd-->

# Intro {#intro}

Este curso é voltado para os alunos de pós-graduação, dessa forma, veremos os conceitos rapidamente. Caso não haja tempo, o conteúdo ficará online no link: https://github.com/iagdevs/cursoR.

Sempre que tiver uma dúvida, tente utilizar: [BASE](http://stat.ethz.ch/R-manual/R-devel/library/base/html/00Index.html).

Outros pacotes BASE: [utils](http://stat.ethz.ch/R-manual/R-devel/library/utils/html/00Index.html), [stats](http://stat.ethz.ch/R-manual/R-devel/library/stats/html/00Index.html), [datasets](http://stat.ethz.ch/R-manual/R-devel/library/datasets/html/00Index.html), [graphics](http://stat.ethz.ch/R-manual/R-devel/library/graphics/html/00Index.html),
[grDevices](https://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/00Index.html), [grid](https://stat.ethz.ch/R-manual/R-devel/library/grid/html/00Index.html), [methods](https://stat.ethz.ch/R-manual/R-devel/library/methods/html/00Index.html), [tools](https://stat.ethz.ch/R-manual/R-devel/library/tools/html/00Index.html), [parallel](https://stat.ethz.ch/R-manual/R-devel/library/parallel/html/00Index.html), [compiler](https://stat.ethz.ch/R-manual/R-devel/library/compiler/html/00Index.html), [splines](https://stat.ethz.ch/R-manual/R-devel/library/splines/html/00Index.html), [tcltk](https://stat.ethz.ch/R-manual/R-devel/library/tcltk/html/00Index.html) , [stats4](https://stat.ethz.ch/R-manual/R-devel/library/stats4/html/00Index.html).

Acesse [aqui](https://cran.r-project.org/web/packages/available_packages_by_name.html) a lista de pacotes disponíveis.

Este curso foi baseado no livro [R Programming for Data Science](https://leanpub.com/rprogramming) e possui <span style="color:red">exercícios</span> a serem resolvidos, <span style="color:blue">perguntas</span> que ajudam a entender conceitos e <span style="color:purple">desafios</span> para aprofundar os conhecimentos adquiridos.

Neste curso iremos utilizar o software [RStudio](https://www.rstudio.com/). A imagem abaixo resume um pouco das funcionalidades disponíveis.

![Fonte: [RStudio IDE Cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/rstudio-ide.pdf)](figuras/rstudio_ide.png)  

Além de poder baixar o programa utilizado nesse curso, você também pode acessar muitos materiais como as [Cheatsheets](https://www.rstudio.com/resources/cheatsheets/) e [Webnários](https://www.rstudio.com/resources/webinars/) que cobrem desde itens básicos como funções essenciais do RStudio até desenvolvimento de páginas para Web ou apps com Shiny. Explore o máximo que puder!  


**Dicas:**

- Se não souber usar uma função, escreva: `?função`
- As funções tem argumentos, use **TAB** para vê-los numa função

## IMPORTANTE

- **TAB** no **RStudio** 

Isso te ajudará a evitar coisas como: grafia errada da função, verificar se a função existe, verificar argumentos, etc... Use sempre!

```{r echo = FALSE}
knitr::include_graphics("figuras/tab-key-.jpeg")
```

- **Stack Overflow** ([Veja as últimas das mais de 240000 (!!!) perguntas sobre R](https://stackoverflow.com/questions/tagged/r))

Melhor forma de resolver problemas! Acredite, é praticamente impossível existir um problema que outra pessoa não tenha resolvido pelo Stack Overflow.

> *Eu mesma só precisei fazer **uma** pergunta no Stack Overflow (e acabei respondendo eu mesma depois de resolver) usando R há uns 5 anos!* - Camila.
  
  
**Vamos começar!**

<!--chapter:end:01-intro.Rmd-->

# R! {#r}

A linguagem R pode ser usada desde uma simples calculadora até uma poderosa ferramenta estatística, seja para análise de dados, seja para machine learning.

Nesse capítulo veremos o básico da linguagem. Como a ideia é cobrir o máximo de conteúdo possível, passaremos bem rápido pelos conceitos básicos, com alguns exercícios para melhor entendimento.

## Variáveis Básicas

Podemos armazenar valores, strings ou operadores lógicos nas chamadas variáveis básicas. É com elas que podemos fazer operações básicas e transformar o RStudio em uma calculadora superpoderosa. Existem 5 tipos de variáveis básicas, sendo elas:

- Numeric (`r 1`): valores numéricos com ou sem casa decimal
```{r}
5+2.3
pi
```
- *Character* (`r "a"`): com eles podemos armazenar strings, como o título de um gráfico
```{r}
titulo <- "Isso é uma string"
titulo
```
- *Integer* (`r 1`): são valores inteiros

- *Complex* (`r 1i`): também é possível armazenar valores complexos nas variáveis básicas
```{r}
3 + 4i
```

- *Logical* (`r TRUE`): são os famosos operadores Booleanos, que permitem realizar comparações entre variáveis ou dados (**Você não pode criar uma variável com os nomes TRUE ou FALSE, esses nomes são reservados pelo R**)
```{r}
1 == 2
```

## Vetores
Vetores permitem que você armazene dados em uma sequência 1D de qualquer um dos tipos listados nas variáveis básicas, mais o formato "cru" (raw) que é o modo de armazenamento de bytes. Por exemplo:

- c("A", "C", "D")
- 1:5 = c(1, 2, 3, 4, 5)
- c(TRUE, FALSE)
- c(1i, -1i)

**Importante: ao contrário do C ou do Python, na linguagem R, a contagem das posições dos vetores começa do 1 e NÃO do zero!**

## Classe

Como foi possível notar, todas as variáveis pertencem a alguma classe, dessa forma, a função `class` permite descobrir qual a classe da variável que se está utilizando:

```{r}
x <- c(1,2,3)
class(x)
```

***  
<span style="color:red">**Exercício**: Qual a classe dos seguintes vetores?</span>

`c(1, “C”, “D”)`  
`c(1, NA, “D”)`   
`c(1, NA, NaN)`  

***

## Converter objetos 
Às vezes quando trabalhamos com dados, podemos precisar "arredondar" valores ou converter vetores em listas, para isso existem algumas funções especiais.

### `as`

Um modo de forçar um objeto a assumir outra classe é por meio da função `as`:

```{r}
as.integer(c(1.5, 2.9, 1))
```

Note que a função apenas converte os números de decimais para inteiros, sem arredondar para o número mais próximo.

*** 
<span style="color:blue">**Pergunta**: O que acontece quando se tenta converter o seguinte vetor?</span>  

`as.numeric(c(1, "C", "D"))`  

***

### `merge` e `melt` {#convert_df}

Nem sempre os conjuntos de dados que você encontrar pela vida estarão no formato desejado para plotar e/ou analisar estatisticamente, dessa forma, essas duas funções poderão ajudar na sua jornada:

-  `merge`: permite a união entre dois [data frames](#dataframes), seja por colunas em comum ou linhas em comum
-  `melt`: do pacote [reshape2](https://cran.r-project.org/web/packages/reshape2/reshape2.pdf), permite que você agrupe várias colunas em função de outra coluna em comum, de acordo com o nome especificado

## Array

Ao contrário do vetor unidimensional, arrays permietm que você armazene dados em diversas dimensões, sendo todas com o mesmo comprimento.  

Vamos dar uma olhada nos argumentos da função:  

```{r}
args(array)
```

Dessa forma, é preciso "informar" ao R qual o número de dimensões que você quer no seu array:

```{r}
a <- array(data = 0, dim = c(1,1))
class(a)
```

No caso acima, como só foram desiginadas duas dimensões, o array é igual a uma matriz.

```{r}
a <- array(data = 0, dim = c(3,3,1))
class(a)
```

Como dá pra ver acima, é possível armazenar diversos elementos em um array, como por exemplo as dimensões que utilizamos no dia-a-dia de modelos numéricos: espaço (x,y,z) e tempo (z). Dessa forma, podemos criar arrays a partir de vetores e armazená-los em diverssas dimensões.

```{r}
vetor1 <- c(1,2,3,4,5)
vetor2 <- c(10,12,14,16,18,20,22,24)

a <- array(data = c(vetor1,vetor2), dim = c(3,3,2))
class(a)
```

Se você quiser, também é possível nomear as colunas e linhas do seu array:

```{r}
colunas <- c("col1", "col2", "col3")
linhas <- c("lin1", "lin2", "lin3")

array(data = c(vetor1, vetor2), dim = c(3, 3, 2), dimnames = list(linhas, colunas))
```

Além disso, sempre que precisar acessar elementos do seu array é só especificar aas dimensões como para mostrar o elemento de um vetor.

```{r}
a[1,2,2] #(linha, coluna, matriz)
```

***  
<span style="color:red">**Exercício**: Crie um array com 3 dimensões, contendo três linhas e 4 quatro colunas. Acesse o elemento da segunda linha e terceira coluna desse array. Não esqueça de verificar a classe desse objeto!</span>  

***


## Matrizes e a função `matrix`

Uma matriz é um array com duas dimensões, sendo necessário informar o número de colunas e linhas, mas não o de dimensões.

Assim como em arrays, só são permitidos elementos **da mesma clase**!

Argumentos da função `matrix`:

```{r}
args(matrix)
```

Colocando dados em uma matriz:

```{r}
m1 <- matrix(data = 1:(4*4), nrow = 4, ncol = 4)
dim(m1)
```

Por padrão, a opção "byrow" é igual a **FALSE**. Quando passamos para **TRUE**, é possível organizar os dados por linha.

```{r}
m2 <- matrix(data = 1:(4*4), nrow = 4, ncol = 4, byrow = TRUE)
```

***
<span style="color:red">**Exercício**: Construa uma matriz com três linhas que contenha os números de 1 a 9.</span>

***


## Listas

Já as listas permitem que você armazene qualquer tipo de variável básica, independente da classe. Dessa forma, podemos colocar numa lista: número, caracteres, argumentos lógicos, ou que você quiser:

```{r}
list(list(list(list(1))))
```

Isso faz com que elas sejam bastante versáteis e sirvam para armazenar o que você precisar, mas elas só podem ter uma dimensão, como uma fila. Já os objetos armazenados dentro da lista não precisam ter a mesma dimensão.

```{r}
x <- list(1, "a", TRUE, 1 + 4i)
```

***  
<span style="color:red">**Exercício**: Crie uma lista contendo um vetor, uma matriz e um data frame e acesse o segundo elemento dela.</span>  

<span style="color:red">Para facilitar, já vamos te dar o data frame:</span>
```{r}
my_df <- mtcars[1:10,]
```

***


## Data Frames {#dataframes}

Os data frames são uma forma de armazenar seus dados em um formato parecido com uma planilha de excel. Você pode pensar em um data frame como uma matriz que armazena em cada coluna um dado diferente, ou como uma lista onde todos os elementos tem o mesmo comprimento.

```{r}
df <- data.frame(a = 1:3)
names(df)
class(df)
mode(df)
```

É normalmente em um data frame que você importará os seus dados e vale saber como visualizar algumas informações básicas sobre ele direto no seu console. Para isso, vamos pegar como exemplo o conjunto `mtcars` da base de dados do R:

```{r}
df <- mtcars
head(df) #mostra as sete primeiras linhas do data frame
```

Para ver as últimas linhas do data frame basta usar a função `tail`. Já uma função muito útil é a `summary`, que apresenta um "resumo" dos seus dados, como média, mediana, mínimos e máximos para cada **coluna** do data frame.

```{r}
summary(df)
```

Iremos trabalhar bastante com data frames daqui pra frente, eles se tornarão aliados muito poderosos.

## Tempo e Data

O R trabalha com três classe de tempo: `POSIXct`, `POSIXlt` e `Date`, sendo que `POSIXct` se refere ao número de segundos desde o início de 1970 no modo UTC, enquanto que `POSIXct` armazena as datas como uma lista, contendo segundos, minutos, horas, dias, meses, etc.

```{r}
a <- ISOdate(year = 2018, month = 4, day = 5)
class(a)
b <- ISOdate(year = 2018, month = 4, day = 5, tz = "Americas/Sao_Paulo")
```

Já a classe `Date`, armazena as datas como o número de dias contados a partir de 1970.

```{r}
c <- as.Date(Sys.time())
class(c)
```

Caso você precise, o pacote [nanotime](https://github.com/eddelbuettel/nanotime) permite trabalhar com nano segundos.

Também é possível fazer sequências:

```{r}
hoje <- Sys.time()
a <- seq.POSIXt(from = hoje, by = 3600, length.out = 24)
```

Funções úteis: `weekdays`, `month` e [`julian`](https://en.wikipedia.org/wiki/Julian_day)

```{r}
weekdays(a)
months(a)
julian(a) #dia Juliano
```

O formato `POSIXct` é o mais comumente usado principalmente se os dados analisados serão plotados.


## Fatores

Os `factors` podem ser um pouco infernais. Dê uma olhada em [R INFERNO](http://www.burns-stat.com/documents/books/the-r-inferno/).  
Usados em análise estatísica, fatores são usados para armazenar variáveis categóricas, ou seja, é uma variável que pode pertencer a um número limitado de categorias, como por exemplo, dias da semana. Já uma variável contínua pode assumir um um número infinito de valores.

```{r}
a <- seq.POSIXt(from = hoje , by = 3600, length.out = 24*7)
aa <- weekdays(a)
class(aa)
```

```{r}
factor(aa)
```

São muito úteis para regressões, gráficos e resumos estatísitcos, uma vez que limita o número de possibilidades para a qual o dado pertença. Além disso, é possível estabelecer "níveis" que vão designar a categoria do seu dado.

```{r}
ab <- factor(x = aa,
             levels = c("Monday", "Tuesday",  "Wednesday",  "Thursday",
                        "Friday", "Saturday", "Sunday"))
levels(ab)
```

***  
<span style="color:red">**Exercício**: Converta o vetor abaixo em um fator e mostre os seus níveis</span>

`genero <- c("Masculino", "Masculino", "Feminino", "Masculino", "Feminino", "Feminino")`

***

Se tudo pareceu muito corrido, não se preocupe, todos esses conceitos serão praticados mais adiante!

<!--chapter:end:02-basicr.Rmd-->

```{r setup, cache = F}
#-- Opção para deixar possível visualizar erros
knitr::opts_chunk$set(error = TRUE)
```

# Importando e Exportando Dados

## Base

### Importando com `read.*`

Como vimos anteriormente, na maioria dos casos, iremos usar data frames par lidar com dados em R, sendo assim, podemos utilizar os seguintes modos de leitura: 

- `read.csv`  
- `read.csv2`  
- `read.table`  

Vamos ler alguns dados usando `read.table`. Para saber o que a função faz, use `?read.table`.  
Os argumentos da função são:

```{r}
args(read.table)
```

O terceiro argumento é `sep`, definido como `""` por padrão. Esse argumento indica para o R qual o tipo de separador utilizado entre as colunas dos dados.

```{r}
df <- read.table("dados/NOXIPEN2014.txt")
```

Lembre-se que as funções `head` e `tail` permitem que você veja as primeiras ou últimas linhas do data frame.

```{r}
head(df)
tail(df)
```

Vamos tentar ler outra versão dos mesmos dados utilizando a mesma função `read.table`:

```{r}
df2 <- read.table("dados/NOXIPEN2014v2.txt")
```

Apareceu uma mensagem de erro, <span style="color:blue">você saberia dizer o porquê?</span>  

**Caso você trabalhe com algum banco de dados em formato .txt e quiser abrir no R... Abra-os no bloco de notas primeiro!**

Vamos dar uma olhada em alguns dados, o primeiro tem uma cara assim:

```{r echo = FALSE}
knitr::include_graphics("figuras/f1.png")
```

Já o segundo arquivo é assim:

```{r echo = FALSE}
knitr::include_graphics("figuras/f2.png")
```

Você notou a diferença? Como vimos anteriormente, para importar os dados no R é super importante que você especifique o tipo de separador utilizado. Como o segundo arquivo é separado por ";", precisamos espercificar o argumento `sep` na hora de usar o comando `read.table`:

```{r}
df2 <- read.table("dados/NOXIPEN2014v2.txt", sep = ";")
head(df2)
tail(df2)
```

Além desses comandos, vocês também pode utilizar a opção **Import Dataset** do RStudio, permitindo que você tenha um "preview" dos dados - como no Excel, mas melhor!

Para mais informações sobre importar dados no R, dê uma olha nesse [webnário](https://www.rstudio.com/resources/webinars/importing-data-into-r/).

### Exportando com `write.table`

Exportar é bem facil. Vamos dar uma olhada nos argumentos da função `write.table`:

```{r}
args(write.table)
```

Se temos um data frame com colunas de classe character, `quote = TRUE` quer dizer que o arquivo de texto resultante vai ter aspas nas colunas de caractere. Novamente, o argumento `sep` indica como podemos separar as colunas. Se você quiser abrir esses dados no excel, uma boa opção é utilizar os separadores ","/";"/" "/"\t", sendo o último o separador que indica o espaçamento criado pela tecla TAB.

Já o argumento `eol` quer dizer _end of line_, e é uma forma de dizer ao R que a linha acaba ali. 
Por padrão, a opção `row.names` vem com a opção TRUE, mas sempre coloque a opção FALSE, caso contrário, será adicionada uma coluna com os índices das linhas. O argumento `col.names` indica se você quer nomear as suas colunas, o que é sempre uma boa ideia.

***  
<span style="color:red">**Exercício**: Usando o conjunto de dados `mtcars` da base do R, exporte-o de uma forma que ele possa ser lido em algum Excel genérico. Não esqueça de usar o que foi ensinado acima.

***

### Exportando objetos com `save`

Podemos salvar objetos do R com o comando `save`. Ele permite que você recarregue o objeto mais tarde.

```{r}
args(save)
```

Essa função salva o objeto com a extensão .rda sendo que para carregá-lo de volta usamos a função `load`

```{r}
args(load)
```

Muito cuidado ao utilizar esse comando, pois é bem possível cometer alguns deslizes, como trocar o nome do objeto. Veja esse exemplo abaixo:

```{r eval=FALSE}
#Primeiro vamos ler os dados do dia 01/06/2016 para uma estação automática do INMET de Paracatu:
paracatu <- read.csv(file = "dados/paracatu.csv", sep = ",") #lendo como csv

# Vamos dizer que queremos salvar apenas a coluna correspondente à temperatura máxima horária:
paracatu_temp <- paracatu$temp_max  

#Agora vamos salvar o objeto do tipo numeric com o nome especificado:
save(paracatu_temp, file = "Temp_max.rda")
```

Passado um tempo, queremos acessar de volta esse objeto, mas não lembramos se salvamos a temperatura máxima ou mínima, vamos confiar que foi a mínima:

```{r eval = FALSE}
load("Temp_min.rda")
```

E assim descobrimos que não era... O que nos ensina a sempre guardar na memória quais variáveis que salvamos no ambiente R. O bom dessa função é que ela permite salvar com tipos de compressão, por exemplo `compress = "xz"`.

### Exportando objetos com `saveRDS`

Esta é uma das minhas funçoes favoritas no R, veja só o porquê:

```{r eval = FALSE}
saveRDS(paracatu_temp, "Temperatura.rds")
```

```{r eval = FALSE}
frenteQ <- readRDS("Temperatura.rds")
```

Você pode salvar seu objeto R de forma serializada e compactada com o argumento `compress` e na hora de chamar o objeto de volta é só usar `readRDS` e colocar o nome que você quiser.

### Processando nossa data frame {#processing_dfs}

Vamos revisar a classe de cada coluna do nosso data-frame com a função `sapply`, que será explicada em outro capítulo. Lembre-se, qualquer dúvida é só usar `?sapply`.

```{r}
sapply(df, class)
```

Quando trabalhamos com séries temporais, é importante ter a variável tempo reconhecida como "tempo", especificamente como classe "POSIXct". Porém, a classe do tipo Data é "factor" assim como a Hora, o que pode ser ruim. Então, vamos criar uma variável de tempo mais padronizada com o formato `r Sys.time()`.

Para isso temos que juntar as variáveis Data e Hora. Faremos isso numa nova varável chamada "tempo_char", adicionando-a diretamente no data frame com o cifrão ("$"). Podemos fazer isso com as funções `paste` ou `paste0`.

```{r}
df$tempo_char <- paste(df$Data, df$Hora)
head(df$tempo_char)
class(df$tempo_char)
```

Melhorou, mas ainda tem clase `r class(df$tempo_char)`.

Para converter a nossa classe para POSIXct podemos usar a função `as.POSIXct` (olhe  
`?as.POSIXct`). Seus argumentos são:

```{r}
args(as.POSIXct)
```

Então, vamos criar outra variável tempo com o formato POSIXct:

```{r}
df$tempo <- as.POSIXct(x = df$tempo_char, tz = "Americas/Sao_Paulo", 
                       format = "%d/%m/%Y %H:%M")
head(df$tempo)
class(df$tempo)
```

Agora, vamos extrair os dias da semana do tempo, mes e dia juliano:

```{r}
df$weekdays <- format(df$tempo, "%A")
head(df$weekdays)

df$mes <- format(df$tempo, "%B")
head(df$mes)

df$diajuliano <- julian(df$tempo)
head(df$diajuliano)

df$ano <- format(df$tempo, "%Y")
```

Pronto! Agora temos o tempo no formato que desejamos.

#### `aggregate`

Vamos dar uma olhada no nosso data frame:

```{r}
head(df)
```

Podemos calcular a média horaria por dia da semana:

```{r}
dff <- aggregate(df$MediaHoraria, by = list(df$weekdays), sum, na.rm = T)
dff
names(dff) <- c("dias", "MediaHoraria")
```

```{r}
dff$sd <- aggregate(df$MediaHoraria, 
                    by = list(df$weekdays), 
                    sum, na.rm = T)$x
dff
```


#### Subset

Como podemos escolher só o mês de janeiro??

```{r}
#[     LINHAS    ,  COLUNAS   ]
head(df[df$mes == "janeiro", ]) #TODAS AS COLUNAS
```

Só que agora temos só a média horária para esse mês, que retorna um vetor numérico:

```{r}
names(df)
head(df[df$mes == "janeiro", 10]) 
head(df[df$mes == "janeiro", "MediaHoraria"])
class(df[df$mes == "janeiro", "MediaHoraria"])
```

Dessa forma, vamos salvar nosso data frame:

```{r}
saveRDS(df, "dados/df.rds")
```

### Data.table e mais

O data.table é um pacote que apresenta a classe `data.table`, que é como uma versão melhorada da classe `data-frame` O termo especifico é que `data-table` tem um "parentesco" (inherits) com a classe `data.frame`

Vamos ver como funciona data.table lendo os dois arquivos e comparar quanto tempo demora cada um.

```{r}
df1 <- print(system.time(read.table("dados/NOXIPEN2014.txt", h = T)))
```

```{r}
library(data.table)
df2 <- print(system.time(fread("dados/NOXIPEN2014.txt", h = T)))
```

Para isso usamos a função `fread`.

## Tidyverse

Um método mais recente (e muito interessante!) de tratar data frames é usando os pacotes dentro do [Tidyverse](https://www.tidyverse.org/).  
Usando diversas funções dos pacotes **readr**, **tidyr** e **dplyr**, por exemplo, é possível ler e processar dados de uma maneira mais *user-friendly* devido à sintaxe das funções e de como elas podem ser usadas em conjunto.  
Note que muitas das funções usadas abaixo podem ser encontradas em Base ou em outros pacotes.

### Importando dados

Todas as funções de leitura possuem a mesma estrutura:  

```{r, eval = F}
read_*(arquivo, 
       col_names = TRUE, 
       col_types = NULL, 
       locale = default_locale(), 
       na = c("", "NA"),
       quoted_na = TRUE, 
       comment = "", 
       trim_ws = TRUE, 
       skip = 0, 
       n_max = Inf, 
       guess_max = min(1000, n_max), progress = interactive())
```

*Dica: Quando a descrição de uma função mostra os argumentos já definidos (`col_names = TRUE`), isso significa que esses são os valores padrão e que você não precisa escrever os argumentos se não quiser mudá-los*  

Assim, todas as funções de leitura só precisam do nome do arquivo!  

Então como ler diferentes arquivos? Usando diferentes funções.

- `read_csv` lê arquivos .csv **separados por $,$**  
- `read_csv2` lê arquivos .csv **separados por $;$**  
- `read_delim` lê arquivos **com outros separadores** (definidos com o argumento `delim`)  
- `read_fwf` lê arquivos **com delimitação fixa** (definidos com o argumento `col_positions`)  
- `read_xl` lê arquivos **Excel** (.xls e .xlsx)  

### Leitura `%>%` Processamento

Existem funções de leitura e modificação de data frames. Muitas vezes, você precisa lidar com dados "brutos" e que precisam de um certo processamento antes de serem utilizados em cálculos e gráficos. Isso exige no mínimo duas funções em duas linhas de código (uma para ler e outra para modificar), mas em geral esse processo precisa de bem mais do que isso.  

O operador `%>%` (chamada de *pipe*) está dentro do pacote magnittr (dentro do Tidyverse) e é muito útil nesse processo! ([Leia um pouco sobre ele aqui](https://www.datacamp.com/community/tutorials/pipe-r-tutorial))  

Como ele funciona?  

> variável %>% função1(., faz a modificação 1) %>% função2(., faz a modificação 2) %>% ... funçãon(., faz a modificação n)

O ponto (.) acima indica que a função será aplicada na versão da variável que chega nela.  
Em notação matemática, podemos dizer que $x \ \ \%>\% \ \ f(y) = f(x,y)$.  
Por exemplo, observe o código abaixo:

```{r, message=F}
library("tidyverse")

seq(1, 10) %>% order(., decreasing = T) %>% paste(., "vezes")
```

O vetor (que não precisa necessariamente ser definido como uma variável) é primeiro ordenado de forma decrescente e, a partir dessa modificação, é transformado em um vetor de caracteres ao colar a string "vezes" a ele.  

Uma forma de fazer isso sem usar `%>%` seria:  

```{r}
paste(order(seq(1, 10), decreasing = T), "vezes")
```

<span style="color:blue">**Pergunta**: Na sua opinião, qual é o código mais fácil e rápido de ser entendido?</span>  

Como isso pode ser aplicado a data frames?



## Outros Tipos de Dados


### NetCDF

O NetCDF (Network Common Data Form) é um conjunto de bibliotecas de software e formatos de dados independentes de máquina e autodescritivos com suporte para criação, acesso e compartilhamento de dados científicos orientados a matrizes. Arquivos NetCDF (criado por essa biblioteca ou por programas que utilizam essa biblioteca) são arquivos compostos por dados, atributos e metadados.

O pacote `ncdf4` pode ser usado para acessar a essa biblioteca, os comandos abaixo instalam e carregam esse pacote:

```{r }
#install.packages("ncdf4") # instala o pacote
library("ncdf4")          # carrega o pacote
nc_version()              # que retorna a versão da biblioteca
```

Um exemplo de NetCDF:

```{r, eval=F}
wrf <- ncdf4::nc_open("dados/met_em.d03.2016-01-10.nc")
```

O objeto `wrf` contém algumas informações sobre o conteúdo do arquivo, com um `print(wrf)` ou simplesmente `wrf` visualizamos o conteúdo do arquivo:

```{r, eval=F}
class(wrf)
wrf
```

Isso mostra o nome do arquivo (e versão da biblioteca usada para criar), número de variáveis (92 no arquivo de exemplo), uma descrição de cada variável (incluindo atributos) as dimensões (13 para esse arquivo) e os atributos globais.

Agora vamos abrir alguma variável:

```{r, eval=F}
names(wrf$var)                # print no nome de cada variavel
TEMP <- ncdf4::ncvar_get(wrf, "TT")  # escolho você picachu
class(TEMP)
```

Como o NetCDF é organizado para guardar matrizes (arrays), só sabemos que a variável `ST` é um array

```{r, eval=F}
ncatt_get(wrf,"TT") # ou ncatt_get(wrf,"TT",verbose = T)
dim(TEMP)
```

praticamente a mesma informação do print anterior:
```
float TT[west_east,south_north,num_metgrid_levels,Time]   
FieldType: 104
MemoryOrder: XYZ
units: K
description: Temperature
stagger: M
sr_x: 1
sr_y: 1
```

como temos apenas 1 tempo essa dimensão é desconsiderada para simplificar.

A latitude de cada ponto de grade, assim como longitude níveis e tempo podem ser extraídas:

```{r, eval=F}
lat  <- ncvar_get(wrf, "XLAT_M")
lon  <- ncvar_get(wrf, "XLONG_M")
time <- ncvar_get(wrf, "Times")
```
O metadado de Longitude:
```
float XLONG_M[west_east,south_north,Time]   
FieldType: 104
MemoryOrder: XY 
units: degrees longitude
description: Longitude on mass grid
stagger: M
sr_x: 1
sr_y: 1
```
Latitude:
```
float XLAT_M[west_east,south_north,Time]   
FieldType: 104
MemoryOrder: XY 
units: degrees latitude
description: Latitude on mass grid
stagger: M
sr_x: 1
sr_y: 1
```
e a altura:
```
float GHT[west_east,south_north,num_metgrid_levels,Time]   
FieldType: 104
MemoryOrder: XYZ
units: m
description: Height
stagger: M
sr_x: 1
sr_y: 1
```
Da mesma forma com que podemos acessar variáveis e atributos com `ncvar_get` e `ncatt_get`, podemos modificar estes valores com `ncvar_put` e `ncatt_put`. Outras operações como renomear (`ncvar_rename`) e trocar o valor de missval (`ncvar_change_missval`) também estão disponíveis.

*DICA*: `ncatt_get` e `ncatt_put` acessam e alteram os atributos de váriaveis e também atributos globais do NetCDF usando o argumento `varid=0`.

Para salvar as alterações e/ou liberar o acesso ao arquivo use a função `nc_close` (ou a função `nc_sync` que sincroniza o NetCDF mas não fecha a conexão com o arquivo).

```{r, eval=F}
nc_close(wrf) # ou nc_sync(wrf)
```

Novas dimensões e também novas variáveis podem ser criadas com `ncvar_def` e `ncvar_add` em um arquivo aberto com permissão de leitura, como por exemplo:
```{r eval=FALSE}
wrf     <- nc_open("~/met_em.d03.2016-01-10.nc", write=TRUE)
extrema <- ncvar_def(name = "Tex",
                     units = "K",
                     dim = list(wrf$dim$west_east,
                                wrf$dim$south_north,
                                wrf$dim$Time),
                     missval = -999,
                     longname = "temperatura extrema")
ncvar_add(wrf, extrema)
names(wrf$var)
nc_close(wrf)
```
Se esse arquivo for aberto novamente vai conter 93 variáveis junto com a variável `Tex` da forma que definimos, caso queria os mesmos atributos que as demais é só usar a função `ncatt_get` na variável.

```{r, eval=F}
wrf <- nc_open("dados/met_em.d03.2016-01-10.nc", write = T)
print(wrf)
```
O pacote possue ainda funções mais específicas para a criação de arquivos em NetCDF como `nc_create`, funções que definem dimenções como `ncdim_def` e funções para colocar e tirar o arquivo de modo de definição `nc_redef` e `nc_enddef`.

*DICA*: o NetCDF no R funciona de forma parecida com ouma lista ou data frame, podemos "ver" ou selecionar suas sub-partes (sub-sub-partes...) com "$" e TAB.

### Dados Binários

**Ler dados binários no R**

Em meteorologia, frequentemente os dados estão em formato binário. A maior "dificuldade" em ler estes dados está em conhecer como eles foram gerados. 

Repare que a função `readBin` requer vários argumentos para ler estes dados da forma correta:

```{r}
args(readBin)
```

Neste curso, o arquivo binário que vamos abrir como exemplo contém dados de temperatura de brilho obtidas com o satélite GOES-13 (informações em: https://disc.gsfc.nasa.gov/datasets/GPM_MERGIR_1/summary).

Lembrem-se de baixar o dado em: https://github.com/iagdevs/cursoR/tree/master/dados

```{r}
# Ler o arquivo binário
l1 <- readBin("dados/gs.140422.1900g.ch4", 
              what="int", 
              n = 1349*1613,
              size = 2)
class(l1)
```

Note que o argumento `endian` por default é `.Platform$endian`. Se rodarmos `.Platform$endian` no R obteremos a ordenação dos bytes ("big" ou "little") utilizada pela plataforma que estamos usando.  

Uma forma rápida para verificarmos os nossos dados é gráfica. Logo, que tal um plot?
```{r}
l2 <- matrix(l1, ncol=1613, nrow=1349)
class(l2)
# Vamos chamar o pacote cptcity para selecionar facilmente uma paleta de cores legal.
library(cptcity)   
image(l2,
      col = cpt(find_cpt("sat")[8]),
      main = "Temperatura de brilho") 
```

Tem algo estranho com esta imagem. O que é? (valendo um sticker).

```{r message=FALSE, warning=FALSE}
library(raster, quietly = TRUE)
l3 <- raster(t(l2[1:1349,1:1613]),
                     xmn=-82.00,
                     ymn=-44.96,
                     xmx=-82.0  + (0.03593245*1349), 
                     ymx=-44.96 + (0.03593245*1613),
                     crs = CRS("+init=epsg:4326"))
class(l3)
```
O capítulo geoespacial será visto no final deste curso. Porém, nesta etapa vamos usar o pacote `raster` somente para analisar se os dados binários foram lidos corretamente.
```{r}
sp::spplot(((l3 + 75)/100)-273, # Estas correções são necessárias. Veja: http://www.cpc.ncep.noaa.gov/products/global_precip/html/README
           col.regions = cpt(find_cpt("sat")[8]),
           at = seq(-80,0,1),
           main = "Temperatura de brilho (ºC)") 
```

**Escrever dados binários no R**

<!--chapter:end:03-import_export.Rmd-->

# Plotando

## `plot` (base)

**Exemplo**: Dados de qualidade do ar

```{r}
df <- readRDS("dados/df.rds")
summary(df)
```

A função `plot` precisa dos seguintes argumentos:

```{r}
args(plot)
```

Então, a forma mais fácil de plotar uma variável em função do tempo é:

```{r}
plot(x = df$tempo, y = df$MediaHoraria)
```

Feio, né?  
Tentando deixar mais bonito...

```{r}
plot(x = df$tempo[1:100], y = df$MediaHoraria[1:100], #-- Selecionando uma parte do df!
     pch = 16, #-- Forma do ponto (círculo preenchido)
     type = "b", #-- Tipo de gráfico ("b" = both, ponto e linha)
     col = "blue", #-- Cor do elemento (definido pelo type)
     xlab = "Data", ylab = "NOx [ppb]", #-- Nome dos eixos x e y
     main = "Gráfico mais Bonito") #-- Título do gráfico
```

Colocando **DOIS** elementos no mesmo gráfico: 

<a id="plot_base"></a>
```{r}
df_parcial <- df[1:180,] #-- Selecionando uma parte do df!
plot(x = df_parcial$tempo[df_parcial$Valido == "Sim"], 
     y = df_parcial$MediaHoraria[df_parcial$Valido == "Sim"],
     pch = 16, type = "b", col = "blue",
     xlab = "Data", ylab = "NOx [ppb]",
     main = "Dados Válidos e Inválidos")
lines(x = df_parcial$tempo[df$Valido == "Não"], 
      y = df_parcial$MediaHoraria[df$Valido == "Não"], 
      pch = 15, type = "b", col = "red")
```
    
***  
<span style="color:purple">**Desafio**: Coloque uma legenda na figura especificando que os dados válidos estão em azul e os inválidos em vermelho </span>
   
***
  
A função `plot` cumpre bem o papel de gerar um gráfico simples, e até permite algumas customizações, mas ela exige cada vez mais linhas de código e argumentos dentro das funções para deixar o gráfico "mais bonito" - ao cumprir o desafio, você irá perceber como uma coisa "simples" como colocar uma legenda pode exigir muito mais do que parece!

## `ggplot` (ggplot2)

A função `ggplot` funciona de um jeito um pouco diferente. Veja a figura abaixo:

![Fonte: https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf](figuras/ggplot_guide.png)

Em vez de uma única função, o gráfico é formado por camadas, sendo que cada camada é um elemento (`geom_...` ou `stat_...`) ou configuração (`scale_..._...`, `coord_...`, `theme` ou `theme_...`, `guides`, `labs`, etc). Consulte a maioria das opções disponíveis em [Data Visualization Cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf).

Que tal refazermos os gráficos da seção anterior?

```{r, message=FALSE}
#-- Não esqueça de carregar o pacote!
library(ggplot2)
```

```{r}
ggplot(df, aes(x = tempo, y = MediaHoraria)) +
  geom_point(pch = 1)
```

```{r}
ggplot(df[1:100,], aes(x = tempo, y = MediaHoraria)) + 
  geom_line(color = "blue") + #-- Linhas...
  geom_point(color = "blue", pch = 16) + #-- ... com pontos
  labs(title = "Gráfico mais Bonito", x = "Data", y = "NOx [ppb]") + #-- Títulos
  theme(plot.title = element_text(hjust = 0.5)) #-- Centralizando o título
```

Agora o mais interessante:

```{r}
ggplot(df[1:180,], aes(x = tempo, y = MediaHoraria)) + 
  geom_line(aes(color = Valido)) +
  geom_point(aes(color = Valido, shape = Valido)) +
  labs(title = "Dados Válidos e Inválidos", x = "Data", y = "NOx [ppb]") +
  scale_color_manual(values = c("red", "blue")) + #-- Definindo as cores manualmente
  scale_shape_manual(values = c(15, 16)) + #-- Definindo as formas manualmente
  theme(plot.title = element_text(hjust = 0.5))
```


<span style="color:blue">**Pergunta**: Qual a principal diferença entre o código acima e o [código usando `plot`](#plot_base)?</span>


A função `ggplot` plota apenas data frames, pois ela mapeia as variáveis por nomes de colunas. Assim, é preciso [converter matrizes ou arrays em data frames](#convert_df).  
Uma vantagem de trabalharmos com data frames, [como já vimos antes](#processing_dfs), é poder manipular esses dados de muitas formas possíveis antes de plotá-los. 

**Continuação do Exemplo**: Extraindo algumas informações sobre os dados

Vamos analisar o ano de 2014:   

* *Em média*, como o NOx varia ao longo do dia?  
    + E para cada dia da semana?  
    + E para cada mês?  
  
Usando algumas funções dentro do pacote **tidyverse**, que funcionam bem com o [*pipe* (`%>%`)](http://r4ds.had.co.nz/pipes.html):

```{r, message=FALSE}
library(tidyverse)

df_2014 <- filter(df, ano == "2014")
df_2014_hour <- df_2014 %>% #-- A partir do data frame df_2014
  group_by(Hora) %>% #-- Agrupe os dados pela coluna hora
  summarise(Media = mean(MediaHoraria, na.rm = T)) %>% #-- E calcule as médias, 
                                                       #-- salvando em uma coluna nova
  mutate(Hora = as.POSIXct(strptime(Hora, "%H:%M"))) %>% #-- Transformando em data
  ungroup() #-- Desagrupando

ggplot(df_2014_hour) +
  scale_x_datetime(date_labels = "%H:%M") + #-- Formato de data que aparecerá no eixo x
  geom_line(aes(x = Hora, y = Media, group = 1), color = "purple") +
  labs(title = "Média Horária Anual", y = "NOx [ppb]")
```

```{r, message=FALSE}
df_2014_weekly <- df_2014 %>%
  group_by(Hora, weekdays) %>% #-- Agrupando os dados pelas colunas Hora e weekdays
  summarise(Media = mean(MediaHoraria, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(Hora = as.POSIXct(strptime(Hora, "%H:%M"))) %>%
  mutate(weekdays = factor(weekdays, levels = c("segunda", "terça", "quarta",
                                                "quinta", "sexta", "sábado", 
                                                "domingo"))) #-- Ordenando os dias da semana

ggplot(df_2014_weekly) +
  scale_x_datetime(date_labels = "%H:%M") +
  geom_col(aes(x = Hora, y = Media), fill = "purple") +
  labs(title = "Média Horária Anual por Dia da Semana", y = "NOx [ppb]") +
  facet_wrap(~ weekdays) #-- Criando paineis em função do dia da semana
```

```{r, message=FALSE}
df_2014_monthly <- df_2014 %>%
  group_by(Hora, mes) %>% #-- Agrupando os dados pelas colunas Hora e mes
  summarise(Media = mean(MediaHoraria, na.rm = T)) %>%
  ungroup() %>%
  mutate(Hora = as.POSIXct(strptime(Hora, "%H:%M"))) %>%
  mutate(mes = factor(mes, levels = c("janeiro", "fevereiro", "março", 
                                      "abril", "maio", "junho", "julho",
                                      "agosto", "setembro", "outubro",
                                      "novembro", "dezembro"))) #-- Ordenando os meses

ggplot(df_2014_monthly) +
  scale_x_datetime(date_labels = "%H:%M") +
  geom_col(aes(x = Hora, y = Media), fill = "purple") +
  labs(title = "Média Horária Anual por Mes", y = "NOx [ppb]") +
  facet_wrap(~ mes) #-- Criando paineis em função do mês
```

***
<span style="color:red">**Exercício**: *Em média*, como **os dados válidos** de NOx variam mensalmente ao longo do ano de 2014? Faça um gráfico.</span>
  
  
<span style="color:purple">**Desafio**: Ainda é possível melhorar os gráficos acima! Pesquise como:</span>  
 
<span style="color:purple">* Diminuir a quantidade de horários no eixo x</span>  
<span style="color:purple">* Separar por dias da semana e meses a partir da coluna "tempo", não precisando usar as colunas de caracteres e consequentemente ordená-las manualmente</span>   
   
***   

### Explorando outras escalas de cores e temas

Pacotes **veinreport** e **cptcity**

```{r eval=F}
devtools::install_github("atmoschem/veinreport")
```

```{r message=F}
library(veinreport)
library(cptcity)
```

Refazendo alguns gráficos:  

```{r}
ggplot(df, aes(x = tempo, y = MediaHoraria)) + 
  geom_line(aes(color = MediaHoraria)) +
  labs(x = "Data", y = "NOx [ppb]") +
  scale_color_gradientn(colours = cpt()) + #-- Definindo as cores com uma escala gradiente
  theme_black()
```

Experimentando escalas de cores com a função `lucky`:

```{r}
ggplot(df_2014_monthly) +
  scale_x_datetime(date_labels = "%H:%M") +
  geom_col(aes(x = Hora, y = Media, fill = Media)) +
  labs(title = "Média Horária Anual por Mes", y = "NOx [ppb]") +
  scale_fill_gradientn(colors = lucky()) + #-- Definindo as cores com uma escala gradiente aleatória
  theme_black() +
  theme(legend.position = "bottom", legend.direction = "horizontal") + #-- Colocando a legenda na parte de baixo da figura
  facet_wrap(~ mes) #-- Criando paineis em função do mês
```

**Este é só o começo!** [Veja aqui um pouco mais das muitas aplicações do `ggplot`](http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html).

<!--chapter:end:04-plotting_ggplotting.Rmd-->

# Estruturas de Controle {#loop}

Em breve.


## if-else

## for

## while

## repeat

## lapply

## sapply

## split

## tapply

## apply

## mapply


<!--chapter:end:05-structures.Rmd-->

# De Scripts a Funções e de Funções a Pacotes {#fx}

Em breve.

<!--chapter:end:06-functions.Rmd-->

# Geo Spatial: `raster`, `sf` e `stars` {#geo}

Em breve.

<!--chapter:end:07-geo-spatial.Rmd-->

`r if (knitr:::is_html_output()) '
# Referências {-}
'`

- [R Programming for Data Science (Leanpub)](https://leanpub.com/rprogramming)  
- [R Graphics Cookbook (Cookbook for R)](http://www.cookbook-r.com/Graphs/)  
- [An Introduction to R (CRAN)](https://cran.r-project.org/doc/manuals/r-release/R-intro.html)  
- [R Data Import/Export (CRAN)](https://cran.r-project.org/doc/manuals/r-release/R-data.html)  
- [RStudio Cheat Sheets (RStudio)](https://www.rstudio.com/resources/cheatsheets/)  
- [Webinars and Videos On Demand (RStudio)](https://www.rstudio.com/resources/webinars/)  
- [Online Learning (RStudio)](https://www.rstudio.com/online-learning/)  
- [Learn the tidyverse (Tidyverse)](https://www.tidyverse.org/learn/)
- [Writing R Extensions (CRAN)](https://cran.r-project.org/doc/manuals/r-release/R-exts.html)  
- [R Internals (CRAN)](https://cran.r-project.org/doc/manuals/r-release/R-ints.html)  
- [R Language Definition (CRAN)](https://cran.r-project.org/doc/manuals/r-release/R-lang.html)  

***
*Quer fazer um documento com o mesmo estilo do nosso? Leia* [bookdown: Authoring Books and Technical Documents with R Markdown (bookdown.org)](https://bookdown.org/yihui/bookdown/)

<!--chapter:end:08-references.Rmd-->


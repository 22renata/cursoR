--- 
title: "Curso de R para Meteorologia IAG/USP"
author: "Sergio Ibarra-Espinosa,\n Amanda Rehbein,\n Daniel Schuch,\n Camila Lopes,\n Isabela Siqueira,\n e possivelmente outros (você está convidado para colaborar)"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: iagdevs/cursoR
description: "Este é um curso de R para Meteorologia. O curso tenta ser abrangente, desde interessados sem formação, passando por graduação e pós-graduação"
---

# Pré-Requisitos {#primero}

## Sistema Operacional

Antes de instalar o R na sua plataforma de interesse, verifique se há recomendações abaixo:

**Windows**  
A princípio não há pré-requisitos! Caso fique entusiasmado com o R e queira desenvolver os próprios pacotes, instale o Rtools https://cran.r-project.org/bin/windows/Rtools/

Instale `NetCDF`, `GDAL`, `GEOS`, `udunits` e `PROJ`
  
**MacOS**  

```{bash eval = FALSE}
brew unlink gdal
brew tap osgeo/osgeo4mac && brew tap --repair
brew install proj
brew install geos
brew install udunits
brew install gdal2 --with-armadillo --with-complete --with-libkml --with-unsupported
brew link --force gdal2
```
(Veja como instalar NetCDF no MacOS)  
  
**Linux (Ubuntu e derivados)**

```{bash eval = FALSE}
sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable --yes
sudo apt-get --yes --force-yes update -qq
# units/udunits2 dependency:
sudo apt-get install --yes libudunits2-dev
# sf dependencies:
sudo apt-get install --yes libproj-dev libgeos-dev libgdal-dev libnetcdf-dev  netcdf-bin gdal-bin
```


## Pacotes usados neste curso

Para fazer este curso instale os seguintes pacotes como indicado:

```{r eval = FALSE}
check.packages <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg))
    install.packages(new.pkg, dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

# Usage example
packages <- c("devtools", "tidyverse", "reshape2", "sf",
              "maptools", "mapview", "fields", "raster",
              "sp", "rgdal", "ncdf4", "data.table",
              "openair", "cptcity")
check.packages(packages)
```
Fonte: https://gist.github.com/smithdanielle/9913897

Descrição de alguns desses pacotes:

* [devtools](https://CRAN.R-project.org/package=devtools) permite a instalação de versões de desenvolvimento de pacotes de diferentes repositórios
* [tidyverse](https://github.com/tidyverse) é o universo de pacotes do Hadley
Wickham para tratamento e visualização de dados  
    + Se você quiser plotar os objetos espaciais sf com o pacote [ggplot2](http://ggplot2.tidyverse.org/) (que faz parte do tidyverse), ele precisa ser instalado usando o devtools (`devtools::install_github("tidyverse/ggplot2")`), pois a função [geom_sf](https://www.isgeomsfinggplot2yet.site/) ainda não está disponível na versão oficial
* [sf](https://github.com/r-spatial/sf), [mapview](https://github.com/r-spatial/mapbiew), raster, sp, rgdal, maptools e fields tratam dados espaciais. Lembre-se que os objetos em Meteorologia são espaço-temporais
* ncdf4 é um pacote para manipular arquivos NetCDF
* [openair](http://davidcarslaw.github.io/openair/) é um pacote para
trabalhar com dados de qualidade do ar e Meteorologia
* [cptcity](https://ibarraespinosa.github.io/cptcity/) é um pacote que tem 7140 paletas de cores do arquivo web [cpt-city](http://soliton.vm.bytemark.co.uk/pub/cpt-city/index.html)
  
Preste atenção na instalação dos pacotes pois eles podem precisar de dependências do sistema.

```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```

## Colaborar

A melhor forma de colaboração é com [*pull requests* no repositório do curso](https://github.com/iagdevs/cursoR/pull/new/master). Aplique o [Guia de Estilo de R do Google](https://google.github.io/styleguide/Rguide.xml) ou o formato [formatR](https://yihui.name/formatr/). Em poucas palavras, lembre que seu código vai ser lido por seres humanos. É possível editar qualquer página usando um dos botões acima.

## Compartilhar dados

Se você conhece alguma fonte de dados para deixar este curso mais legal, edite este arquivo e faça um *pull request*.
  
1. NCEP: ftp://nomads.ncdc.noaa.gov/GFS/analysis_only/
2. ...
3. ...


<!--chapter:end:index.Rmd-->

# Intro {#intro}

Este curso é voltado para os alunos de pós-graduação, dessa forma, veremos os conceitos rapidamente. Caso não haja tempo, o conteúdo ficará online no link: https://github.com/iagdevs/cursoR.

Sempre que tiver uma dúvida, tente utilizar: [BASE](http://stat.ethz.ch/R-manual/R-devel/library/base/html/00Index.html).

Outros pacotes BASE: [utils](http://stat.ethz.ch/R-manual/R-devel/library/utils/html/00Index.html), [stats](http://stat.ethz.ch/R-manual/R-devel/library/stats/html/00Index.html), [datasets](http://stat.ethz.ch/R-manual/R-devel/library/datasets/html/00Index.html), [graphics](http://stat.ethz.ch/R-manual/R-devel/library/graphics/html/00Index.html),
[grDevices](https://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/00Index.html), [grid](https://stat.ethz.ch/R-manual/R-devel/library/grid/html/00Index.html), [methods](https://stat.ethz.ch/R-manual/R-devel/library/methods/html/00Index.html), [tools](https://stat.ethz.ch/R-manual/R-devel/library/tools/html/00Index.html), [parallel](https://stat.ethz.ch/R-manual/R-devel/library/parallel/html/00Index.html), [compiler](https://stat.ethz.ch/R-manual/R-devel/library/compiler/html/00Index.html), [splines](https://stat.ethz.ch/R-manual/R-devel/library/splines/html/00Index.html), [tcltk](https://stat.ethz.ch/R-manual/R-devel/library/tcltk/html/00Index.html) , [stats4](https://stat.ethz.ch/R-manual/R-devel/library/stats4/html/00Index.html).

Acesse [aqui](https://cran.r-project.org/web/packages/available_packages_by_name.html) a lista de pacotes disponíveis.

Este curso foi baseado no livro [R Programming for Data Science](https://leanpub.com/rprogramming) e possui <span style="color:red">exercícios</span> a serem resolvidos, <span style="color:blue">perguntas</span> que ajudam a entender conceitos e <span style="color:purple">desafios</span> para aprofundar os conhecimentos adquiridos.

Neste curso iremos utilizar o software [RStudio](https://www.rstudio.com/). A imagem abaixo resume um pouco das funcionalidades disponíveis.

![Fonte: [RStudio IDE Cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/rstudio-ide.pdf)](figuras/rstudio_ide.png)

**Dicas:**

- Se não souber usar uma função, escreva: `?função`
- As funções tem argumentos, use **TAB** para vê-los numa função

## IMPORTANTE

- **TAB** no **RStudio** 

Isso te ajudará a evitar coisas como: grafia errada da função, verificar se a função existe, verificar argumentos, etc... Use sempre!

```{r echo = FALSE}
knitr::include_graphics("figuras/tab-key-.jpeg")
```

- **Stack Overflow** ([Veja as últimas das mais de 240000 (!!!) perguntas sobre R](https://stackoverflow.com/questions/tagged/r))

Melhor forma de resolver problemas! Acredite, é praticamente impossível existir um problema que outra pessoa não tenha resolvido pelo Stack Overflow.

> *Eu mesma só precisei fazer **uma** pergunta no Stack Overflow (e acabei respondendo eu mesma depois de resolver) usando R há uns 5 anos!* - Camila.
  
  
**Vamos começar!**

<!--chapter:end:01-intro.Rmd-->

# R! {#r}


- Iremos focar no Linux, mas R e RStudio estão disponíveis para Windows e Mac também.
- Documentação:
- [Intro](http://cran.r-project.org/doc/manuals/r-release/R-intro.html).
- [I/O](http://cran.r-project.org/doc/manuals/r-release/R-data.html).
- Quer fazer um pacote? [Veja](http://cran.r-project.org/doc/manuals/r-release/R-exts.html),
[aqui](http://cran.r-project.org/doc/manuals/r-release/R-ints.html) e [aqui](http://cran.r-project.org/doc/manuals/r-release/R-lang.html).
- [Stackoverflow](https://stackoverflow.com/questions/tagged/r) te ajudará em horas de desespero.

## Objetos do R

- Character `r "a"`
- Numeric `r 1`
- Integer `r 1`
- Complex `r 1i`
- Logical `r TRUE`

## Classe

`class` essa função permite ver a classe dos objetos

## Vetores

- c("A", "C", "D")
- 1:5 = c(1, 2, 3, 4, 5)
- c(TRUE, FALSE)
- c(1i, -1i)
- c(1, "C", "D") qual é a classe???
- c(1, NA, "D") qual é a classe???
- c(1, NA, NaN) qual é a classe???

## Converter objetos 

### `as`

```{r}
as.numeric(c(1, "C", "D"))
```

### `merge` e `melt` {#convert_df}

## Matrizes e a função `matrix`

**[linhas, colunas]**

- Só são permitidos elementos **da mesma clase**!

Argumentos da função `matrix`

```{r}
args(matrix)
```

usando TAB

```{r}
(m <- matrix(data = 0, nrow = 4, ncol = 4))
```


```{r}
(m1 <- matrix(data = 1:(4*4), nrow = 4, ncol = 4))
dim(m1)
```


```{r}
(m2 <- matrix(data = 1:(4*4), nrow = 4, ncol = 4, byrow = TRUE))
```

## Array

Permite armazenar diversos elementos, com diversas dimensões. Dessa forma, um array com duas dimensões é o mesmo que uma matriz, dessa forma, podemos armazenar diversas matrizes dentro de um array, mas suas dimensões são pré-estabelecidas.

```{r}
args(array)
```

Não esqueça do TAB

```{r}
(a <- array(data = 0, dim = c(1,1)))
class(a)
```

```{r}
(a <- array(data = 0, dim = c(1,1,1)))
class(a)
```



```{r}
(a <- array(data = 0, dim = c(2,2,2)))
```


```{r}
(a <- array(data = 0, dim = c(2,4,4)))
dim(a)
```


```{r eval = FALSE}
(a <- array(data = 0, dim = c(2, 2,2,2)))
```

## `list`

Já as listas permitem que você armazene qualquer tipo de ojeto, independente da classe, dessa forma, podemos colocar numa lista: número, caracteres, argumentos lógicos, ou que você quiser:

```{r}
list(list(list(list(1))))
```
Isso faz com que elas sejam bastante versáteis e sirvam para armazenar o que você precisar, mas elas só podem ter uma dimensão, como uma fila.

```{r}
(x <- list(1, "a", TRUE, 1 + 4i))
```

## Tempo e Data

R também tem classes de tempo e data:

```{r}
(a <- ISOdate(year = 2018, month = 4, day = 5))
class(a)
(b <- ISOdate(year = 2018, month = 4, day = 5, tz = "Americas/Sao_Paulo"))
```

Tempo

```{r}
(d <- ISOdatetime(year = 2018, month = 4, day = 5, hour = 0, min = 0, sec = 0,
                  tz = "Americas/Sao_Paulo"))
```

Caso você precise, o pacote [nanotime](https://github.com/eddelbuettel/nanotime) permite trabalhar com nano segundos.

É possível fazer sequências:

```{r}
hoje <- Sys.time()
(a <- seq.POSIXt(from = hoje, by = 3600, length.out = 24))

```

funções úteis: **weekdays**, **month**, **julian**

```{r}
weekdays(a)
months(a)
julian(a) #dia Juliano*
```
*Para mais informações: https://en.wikipedia.org/wiki/Julian_day:



## Fatores

Os `factors` podem ser um pouco infernais. Dê uma olhada em [R INFERNO](http://www.burns-stat.com/documents/books/the-r-inferno/)

São variáveis que representam categorias, como por exemplo, dias da semana.

```{r}
a <- seq.POSIXt(from = hoje, by = 3600, length.out = 24*7)
aa <- weekdays(a)
class(aa)
factor(aa)
```
São muito úteis para regressões, plotes e resumos estatísitcos.

Olhe os **Levels**

Então: 

```{r}
ab <- factor(x = aa,
             levels = c("Monday", "Tuesday",  "Wednesday",  "Thursday",
                        "Friday", "Saturday", "Sunday"))
levels(ab)
```

## Data.frames

_lembre ?data.frame_

Lembram uma planilha EXCEL... Mais ou menos

É uma classe bem especial, tem elementos de matriz mas o modo é lista

```{r}
(df <- data.frame(a = 1:3))
names(df)
class(df)
mode(df)
```

Podemos utilizar para armazenar dados, sendo que um data.frame é sempre composto por vetores com comprimento IGUAL

```{r}
nrow(df)
ncol(df)
dim(df)
```

<!--chapter:end:02-basicr.Rmd-->

# Importando e Exportando Dados

## Data Frames

Probabelmente um dos promeiros objetos que vamos usar quando começamos usar R.
Pensa num data-frame como uma planilha de Libreoffice (o excel). Os data-frame
pode ser criaos como foi visto na seção anterior. O principal, é que temos varias
funções para ler data-frames no R, entre elas

- read.csv
- read.csv2
- read.table

Agora vamos a ler dados do repositorio usando read.table, mas primeiro vamos lembrar
que se tu precisar ver a ajuda da função, tem que escrever no R `?read.table`.
Então, agora vamos ver os argumentos da função:

```{r}
args(read.table)
```

Aqui vem-se os valores default dos argumentos da função `read.table`. O terceiro
argumento é sep, com valores por default = "". 


```{r}
df <- read.table("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014.txt")
```

Agora vamos usar a funções `head` and `tail` para ver as primeiras e as ultimas
6 linhas do data-frame.

```{r}
head(df)
tail(df)
```


Agora vamos ler os mesmos dados com outro formato e testar e read.table funciona
do mesmo jeito
```{r eval = FALSE}
df2 <- read.table("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014v2.txt")
# Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : 
# linha 1 não tinha 6 elementos
```

Vemos a mensagem de error, mas o que quer dizer.

**Se tu recever um banco de dados tipo .txt e quer abrir no R... ABRE ELE COM BLOCO DE NOTAS PRIMEIRO!!!**

O primeiro arquivo:

```{r echo = FALSE}
knitr::include_graphics("figuras/f1.png")
```

O segundo arquivo é:

```{r echo = FALSE}
knitr::include_graphics("figuras/f2.png")
```


qual é a diferença?


Como vemos o segundo arquivo tem separação de ";", entao, temos que lero arquivo
assim:

```{r}
df2 <- read.table("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014v2.txt", sep = ";")
head(df2)
tail(df2)
```

**Qua dificultades tu já enfrentou importando dados?**

## BASE
  
### Exportando texto com `write.table`

Exportar é bem facil, mas se sabemos os argumentos das funções, vai ser
mais eficiente ainda. Vamos `write.table`

```{r}
args(write.table)
```

Se temos um data-frame com colunas de classe character, `quote = TRUE`
quer dizer que o arquivo de texto resultante vai ter aspas nas colunas
de caracter.

`sep` é como vão ser separadas as colunas. Se tu quer abrir o arquivo com
Excel, poderia separar com ",", ";", " ", "\t"... Depende como tu quer.

eol quer dizer _end of line_, e é para ver a forma de colocar o "end of 
line"

**row.names**.. esta  TRUE mas SEMPRE SEMPRE SEMPRE COLOCA:

**row.names = FALSE**. Se não, R vai adiiconar uma coluna com os indices
das linhas....

col.names se tu quer o nome nas colunas...

**PRATICA!**

### Exportando objetos com `save`


```{r}
args(save)
```

`save` salva o objeto com a extensão .rda. Para carregar de volta o
objeto, tem que ser feito com a função `load`


```{r}
args(load)
```

O que pode ser ruim, porque as vezes tu esqueceu o nome do objeto no
ambiente de R. Por exemplo, tu salvou o arquivo

```{r eval=FALSE}
save(frenteFria, file = "FrenteQuente.rda")
```


logo tu carrega

```{r eval = FALSE}
load("FrenteQuente.rda")
```

acreditando que vai ter tua frente quente, mas o nome do objeto no 
ambiente de R é frenteDria... então, tem que ficar de olho, e como somos
imperfeito, vai dar merda....

O melhor da função é que permite salvar com tipos de compressão, por 
exemplo compress = "xz".

### Exportando objetos com `saveRDS`

Esta é uma das minhas funçoes favoritas no R

```{r}
args(saveRDS)
```

e

```{r}
args(readRDS)
```


Tu consegue salvar o objeto R de forma serializada e compactada
com o argumento `compress` mas o melhor é quando vai chamar o objeto 
de volta ao R. Agora tu usa o `readRDS` e coloca o nome que tu
quiser.

```{r eval = FALSE}
saveRDS(FrenteQuente, "FrenteQuente.rds")
```

```{r eval = FALSE}
frenteQ <- readRDS("FremteQuente.rds")
```


### Processando nossa data-frame {#processing_dfs}

Tem numeroas formas e pacotes para ordenar, arrangiar (Arrange), mutar e cambiar
as data-frames. As mais conhecidas são provablemente do universe *tidyverse* com 
o famoso pacote _dplyr_. Mas, nesta curso vamos focar em **base**.

Vamos então revisar a classe de cada columna do nosso data-frame com a função
`sapply`, apresentada em outro capitulo, mas se quiser, da uma olhada em `?sapply`.

```{r}
sapply(df, class)
```

Quando nos trabalhamos com series de tempo, é importante ter a variabel de tempo
reconhecida como "tempo", especificamente como classe "POSIXct". Mas, a classe de
Data é "factor" e de Hora tambem "factor", o que é ruim. Então, vamos criar uma
variabel de tempo mais standard com formato `r Sys.time()`.

Para isso temos que grudar as variabel Data e Hora. Faremios isso numa nova
varaibel chamada tempo_char, adicionando ela diretamente no `df` com o cifrão 
DOLLAR $. O grude pode ser feito com as funções `paste` ou `paste0`.

```{r}
df$tempo_char <- paste(df$Data, df$Hora)
head(df$tempo_char)
class(df$tempo_char)
```

Esta melhorando mas ainda tem clase `r class(df$tempo_char)`.

Para convertir a nossa classe POSIXct podemos usar a função `as.POSIXct` (olha 
`as.POSIXct`). Seus argumentos são:

```{r}
args(as.POSIXct)
```


Então, vamos criar outra variabel tempo o formato POSIXct

```{r}
df$tempo <- as.POSIXct(x = df$tempo_char, tz = "Americas/Sao_Paulo", 
                       format = "%d/%m/%Y %H:%M")
head(df$tempo)
class(df$tempo)
```

Agora, vamos a extraer os dias da semana do tempo, mes e dia juliano:

```{r}
df$weekdays <- format(df$tempo, "%A")
head(df$weekdays)
df$mes <- format(df$tempo, "%B")
head(df$mes)
df$diajuliano <- julian(df$tempo)
head(df$diajuliano)

df$ano <- format(df$tempo, "%Y")
```

### aggregate

Vamos a carregar a nossa data.frame. Primero uma olhada

```{r}
head(df)
```

Poderiamos calcular a media horaria por dia da semana. Então:

```{r}
dff <- aggregate(df$MediaHoraria, by = list(df$weekdays), sum, na.rm = T)
dff
names(dff) <- c("dias", "MediaHoraria")
```

```{r}
dff$sd <- aggregate(df$MediaHoraria, 
                    by = list(df$weekdays), 
                    sum, na.rm = T)$x
dff
```


### subset

Como poderiamos escolher só o mes de janeiro??

```{r}
#[     LINHAS    ,  COLUNAS   ]
head(df[df$mes == "janeiro", ]) #TODAS AS COLUNAS
```


Mes janeiro pero solo o valor mediahoraria, que retorna um vetor numerico

```{r}
names(df)
head(df[df$mes == "janeiro", 10]) 
head(df[df$mes == "janeiro", "MediaHoraria"])
class(df[df$mes == "janeiro", "MediaHoraria"])
```

Mas vamos salvar o nosso "df"

```{r}
saveRDS(df, "dados/df.rds")
```


### data.table, read_xl e mais

data.table é um pacote que apresenta a classe `data.table`, que é como uma versão
melhorada da classe `data-frame` O termo especifico é que `data-table` tem 
herencia (inherits) da classe `data.frame`

Vamos ver como funciona data.table lendo o dois arquivos e comparar quanto tempo
demoram cada um.

```{r}
df1 <- print(system.time(read.table("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014.txt", h = T)))
```

```{r}
library(data.table)
df2 <- print(system.time(fread("https://raw.githubusercontent.com/ibarraespinosa/cursoR/master/dados/NOXIPEN2014.txt", h = T)))

```



olha que estamos usando a função `fread`.

read_xl é mais uma função do universo tidyverse que permite importar excel no R, diretamente e inteligentemente.

## Tidyverse
  
### Leitura `%>%` Processamento

## Outros Tipos de Dados
  
### NetCDF

O NetCDF (Network Common Data Form) é um conjunto de bibliotecas de software e formatos de dados independentes de máquina e autodescritivos com suporte para criação, acesso e compartilhamento de dados científicos orientados a matrizes. Arquivos NetCDF (criado por essa biblioteca ou por programas que utilizam essa biblioteca) são arquivos compostos por dados, atributos e metadados.

O pacote `ncdf4` pode ser usado para acessar a essa biblioteca, os comandos abaixo instalam e carregam esse pacote:
```{r }
#install.packages("ncdf4") # instala o pacote
library("ncdf4")          # carrega o pacote
nc_version()              # que retorna a versão da biblioteca
```
Um exmplo de NetCDF:
```{r}
download.file("https://github.com/ibarraespinosa/cursoR/raw/master/dados/met_em.d03.2016-01-10.nc", destfile = "~/met_em.d03.2016-01-10.nc")
```

```{r}
wrf <- ncdf4::nc_open("~/met_em.d03.2016-01-10.nc")
```


O objeto `wrf` contém algumas informações sobre o conteúdo do arquivo, com um `print(wrf)` ou simplesmente `wrf` visualizamos o conteúdo do arquivo:
```{r}
class(wrf)
wrf
```
que mostra o nome do arquivo (e versão da biblioteca usada para criar), número de variáveis (92 no arquivo de exemplo), uma descrição de cada variável (incluindo atributos) as dimensões (13 para esse arquivo) e os atributos globais.

Agora vamos abrir alguma variável:
```{r}
names(wrf$var)                # print no nome de cada variavel
TEMP <- ncdf4::ncvar_get(wrf, "TT")  # escolho você picachu
class(TEMP)
```

Como o NetCDF é organizado para guardar matrizes (arrays), só sabemos que a variável `ST` é um array

```{r}
ncatt_get(wrf,"TT") # ou ncatt_get(wrf,"TT",verbose = T)
dim(TEMP)
```

praticamente a mesma informação do print anterior:
```
float TT[west_east,south_north,num_metgrid_levels,Time]   
FieldType: 104
MemoryOrder: XYZ
units: K
description: Temperature
stagger: M
sr_x: 1
sr_y: 1
```

como temos apenas 1 tempo essa dimensão é desconsiderada para simplificar.

A latitude de cada ponto de grade, assim como longitude níveis e tempo podem ser extraídas:

```{r}
lat  <- ncvar_get(wrf, "XLAT_M")
lon  <- ncvar_get(wrf, "XLONG_M")
time <- ncvar_get(wrf, "Times")
```
O metadado de Longitude:
```
float XLONG_M[west_east,south_north,Time]   
FieldType: 104
MemoryOrder: XY 
units: degrees longitude
description: Longitude on mass grid
stagger: M
sr_x: 1
sr_y: 1
```
Latitude:
```
float XLAT_M[west_east,south_north,Time]   
FieldType: 104
MemoryOrder: XY 
units: degrees latitude
description: Latitude on mass grid
stagger: M
sr_x: 1
sr_y: 1
```
e a altura:
```
float GHT[west_east,south_north,num_metgrid_levels,Time]   
FieldType: 104
MemoryOrder: XYZ
units: m
description: Height
stagger: M
sr_x: 1
sr_y: 1
```
Da mesma forma com que podemos acessar variáveis e atributos com `ncvar_get` e `ncatt_get`, podemos modificar estes valores com `ncvar_put` e `ncatt_put`. Outras operações como renomear (`ncvar_rename`) e trocar o valor de missval (`ncvar_change_missval`) também estão disponíveis.

*DICA*: `ncatt_get` e `ncatt_put` acessam e alteram os atributos de váriaveis e também atributos globais do NetCDF usando o argumento `varid=0`.

Para salvar as alterações e/ou liberar o acesso ao arquivo use a função `nc_close` (ou a função `nc_sync` que sincroniza o NetCDF mas não fecha a conexão com o arquivo).

```{r}
nc_close(wrf) # ou nc_sync(wrf)
```

Novas dimensões e também novas variáveis podem ser criadas com `ncvar_def` e `ncvar_add` em um arquivo aberto com permissão de leitura, como por exemplo:
```{r eval=FALSE}
wrf     <- nc_open("~/met_em.d03.2016-01-10.nc", write=TRUE)
extrema <- ncvar_def(name = "Tex",
                     units = "K",
                     dim = list(wrf$dim$west_east,
                                wrf$dim$south_north,
                                wrf$dim$Time),
                     missval = -999,
                     longname = "temperatura extrema")
ncvar_add(wrf, extrema)
names(wrf$var)
nc_close(wrf)
```
Se esse arquivo for aberto novamente vai conter 93 variáveis junto com a variável `Tex` da forma que definimos, caso queria os mesmos atributos que as demais é só usar a função `ncatt_get` na variável.

```{r}
wrf     <- nc_open("~/met_em.d03.2016-01-10.nc",write=T)
print(wrf)
```
O pacote possue ainda funções mais específicas para a criação de arquivos em NetCDF como `nc_create`, funções que definem dimenções como `ncdim_def` e funções para colocar e tirar o arquivo de modo de definição `nc_redef` e `nc_enddef`.

*DICA*: o NetCDF no R funciona de forma parecida com ouma lista ou data frame, podemos "ver" ou selecionar suas sub-partes (sub-sub-partes...) com "$" e TAB.

### Dados Binários

<!--chapter:end:03-import_export.Rmd-->

# Plotando

## `plot` (base)

**Exemplo**: Dados de qualidade do ar

```{r}
df <- readRDS("dados/df.rds")
summary(df)
```

A função `plot` precisa dos seguintes argumentos:

```{r}
args(plot)
```

Então, a forma mais fácil de plotar uma variável em função do tempo é:

```{r}
plot(x = df$tempo, y = df$MediaHoraria)
```

Feio, né?  
Tentando deixar mais bonito...

```{r}
plot(x = df$tempo[1:100], y = df$MediaHoraria[1:100], #-- Selecionando uma parte do df!
     pch = 16, #-- Forma do ponto (círculo preenchido)
     type = "b", #-- Tipo de gráfico ("b" = both, ponto e linha)
     col = "blue", #-- Cor do elemento (definido pelo type)
     xlab = "Data", ylab = "NOx [ppb]", #-- Nome dos eixos x e y
     main = "Gráfico mais Bonito") #-- Título do gráfico
```

Colocando **DOIS** elementos no mesmo gráfico: 

<a id="plot_base"></a>
```{r}
df_parcial <- df[1:180,] #-- Selecionando uma parte do df!
plot(x = df_parcial$tempo[df_parcial$Valido == "Sim"], 
     y = df_parcial$MediaHoraria[df_parcial$Valido == "Sim"],
     pch = 16, type = "b", col = "blue",
     xlab = "Data", ylab = "NOx [ppb]",
     main = "Dados Válidos e Inválidos")
lines(x = df_parcial$tempo[df$Valido == "Não"], 
      y = df_parcial$MediaHoraria[df$Valido == "Não"], 
      pch = 15, type = "b", col = "red")
```
    
***  
<span style="color:purple">**Desafio**: Coloque uma legenda na figura especificando que os dados válidos estão em azul e os inválidos em vermelho </span>
   
***
  
A função `plot` cumpre bem o papel de gerar um gráfico simples, e até permite algumas customizações, mas ela exige cada vez mais linhas de código e argumentos dentro das funções para deixar o gráfico "mais bonito" - ao cumprir o desafio, você irá perceber como uma coisa "simples" como colocar uma legenda pode exigir muito mais do que parece!

## `ggplot` (ggplot2)

A função `ggplot` funciona de um jeito um pouco diferente. Veja a figura abaixo:

![Fonte: https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf](figuras/ggplot_guide.png)

Em vez de uma única função, o gráfico é formado por camadas, sendo que cada camada é um elemento (`geom_...` ou `stat_...`) ou configuração (`scale_..._...`, `coord_...`, `theme` ou `theme_...`, `guides`, `labs`, etc). Consulte a maioria das opções disponíveis em [Data Visualization Cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf).

Que tal refazermos os gráficos da seção anterior?

```{r, message=FALSE}
#-- Não esqueça de carregar o pacote!
library(ggplot2)
```

```{r}
ggplot(df, aes(x = tempo, y = MediaHoraria)) +
  geom_point(pch = 1)
```

```{r}
ggplot(df[1:100,], aes(x = tempo, y = MediaHoraria)) + 
  geom_line(color = "blue") + #-- Linhas...
  geom_point(color = "blue", pch = 16) + #-- ... com pontos
  labs(title = "Gráfico mais Bonito", x = "Data", y = "NOx [ppb]") + #-- Títulos
  theme(plot.title = element_text(hjust = 0.5)) #-- Centralizando o título
```

Agora o mais interessante:

```{r}
ggplot(df[1:180,], aes(x = tempo, y = MediaHoraria)) + 
  geom_line(aes(color = Valido)) +
  geom_point(aes(color = Valido, shape = Valido)) +
  labs(title = "Dados Válidos e Inválidos", x = "Data", y = "NOx [ppb]") +
  scale_color_manual(values = c("red", "blue")) + #-- Definindo as cores manualmente
  scale_shape_manual(values = c(15, 16)) + #-- Definindo as formas manualmente
  theme(plot.title = element_text(hjust = 0.5))
```


<span style="color:blue">**Pergunta**: Qual a principal diferença entre o código acima e o [código usando `plot`](#plot_base)?</span>


A função `ggplot` plota apenas data frames, pois ela mapeia as variáveis por nomes de colunas. Assim, é preciso [converter matrizes ou arrays em data frames](#convert_df).  
Uma vantagem de trabalharmos com data frames, [como já vimos antes](#processing_dfs), é poder manipular esses dados de muitas formas possíveis antes de plotá-los. 

**Continuação do Exemplo**: Extraindo algumas informações sobre os dados

Vamos analisar o ano de 2014:   

* *Em média*, como o NOx varia ao longo do dia?  
    + E para cada dia da semana?  
    + E para cada mês?  
  
Usando algumas funções dentro do pacote **tidyverse**, que funcionam bem com o [*pipe* (`%>%`)](http://r4ds.had.co.nz/pipes.html):

```{r, message=FALSE}
library(tidyverse)

df_2014 <- filter(df, ano == "2014")
df_2014_hour <- df_2014 %>% #-- A partir do data frame df_2014
  group_by(Hora) %>% #-- Agrupe os dados pela coluna hora
  summarise(Media = mean(MediaHoraria, na.rm = T)) %>% #-- E calcule as médias, 
                                                       #-- salvando em uma coluna nova
  mutate(Hora = as.POSIXct(strptime(Hora, "%H:%M"))) %>% #-- Transformando em data
  ungroup() #-- Desagrupando

ggplot(df_2014_hour) +
  scale_x_datetime(date_labels = "%H:%M") + #-- Formato de data que aparecerá no eixo x
  geom_line(aes(x = Hora, y = Media, group = 1), color = "purple") +
  labs(title = "Média Horária Anual", y = "NOx [ppb]")
```

```{r, message=FALSE}
df_2014_weekly <- df_2014 %>%
  group_by(Hora, weekdays) %>% #-- Agrupando os dados pelas colunas Hora e weekdays
  summarise(Media = mean(MediaHoraria, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(Hora = as.POSIXct(strptime(Hora, "%H:%M"))) %>%
  mutate(weekdays = factor(weekdays, levels = c("segunda", "terça", "quarta",
                                                "quinta", "sexta", "sábado", 
                                                "domingo"))) #-- Ordenando os dias da semana

ggplot(df_2014_weekly) +
  scale_x_datetime(date_labels = "%H:%M") +
  geom_col(aes(x = Hora, y = Media), fill = "purple") +
  labs(title = "Média Horária Anual por Dia da Semana", y = "NOx [ppb]") +
  facet_wrap(~ weekdays) #-- Criando paineis em função do dia da semana
```

```{r, message=FALSE}
df_2014_monthly <- df_2014 %>%
  group_by(Hora, mes) %>% #-- Agrupando os dados pelas colunas Hora e mes
  summarise(Media = mean(MediaHoraria, na.rm = T)) %>%
  ungroup() %>%
  mutate(Hora = as.POSIXct(strptime(Hora, "%H:%M"))) %>%
  mutate(mes = factor(mes, levels = c("janeiro", "fevereiro", "março", 
                                      "abril", "maio", "junho", "julho",
                                      "agosto", "setembro", "outubro",
                                      "novembro", "dezembro"))) #-- Ordenando os meses

ggplot(df_2014_monthly) +
  scale_x_datetime(date_labels = "%H:%M") +
  geom_col(aes(x = Hora, y = Media), fill = "purple") +
  labs(title = "Média Horária Anual por Mes", y = "NOx [ppb]") +
  facet_wrap(~ mes) #-- Criando paineis em função do mês
```

***
<span style="color:red">**Exercício**: *Em média*, como **os dados válidos** de NOx variam mensalmente ao longo do ano de 2014? Faça um gráfico.</span>
  
  
<span style="color:purple">**Desafio**: Ainda é possível melhorar os gráficos acima! Pesquise como:</span>  
 
<span style="color:purple">* Diminuir a quantidade de horários no eixo x</span>  
<span style="color:purple">* Separar por dias da semana e meses a partir da coluna "tempo", não precisando usar as colunas de caracteres e consequentemente ordená-las manualmente</span>   
   
***   

### Explorando outras escalas de cores e temas

Pacotes **veinreport** e **cptcity**

```{r eval=F}
devtools::install_github("atmoschem/veinreport")
```

```{r message=F}
library(veinreport)
library(cptcity)
```

Refazendo alguns gráficos:  

```{r}
ggplot(df, aes(x = tempo, y = MediaHoraria)) + 
  geom_line(aes(color = MediaHoraria)) +
  labs(x = "Data", y = "NOx [ppb]") +
  scale_color_gradientn(colours = cpt()) + #-- Definindo as cores com uma escala gradiente
  theme_black()
```

Experimentando escalas de cores com a função `lucky`:

```{r}
ggplot(df_2014_monthly) +
  scale_x_datetime(date_labels = "%H:%M") +
  geom_col(aes(x = Hora, y = Media, fill = Media)) +
  labs(title = "Média Horária Anual por Mes", y = "NOx [ppb]") +
  scale_fill_gradientn(colors = lucky()) + #-- Definindo as cores com uma escala gradiente aleatória
  theme_black() +
  theme(legend.position = "bottom", legend.direction = "horizontal") + #-- Colocando a legenda na parte de baixo da figura
  facet_wrap(~ mes) #-- Criando paineis em função do mês
```

**Este é só o começo!** [Veja aqui um pouco mais das muitas aplicações do `ggplot`](http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html).

<!--chapter:end:04-plotting_ggplotting.Rmd-->

# Estruturas de Controle {#loop}

## if-else

## for

## while

## repeat

## lapply

## sapply

## split

## tapply

## apply

## mapply


<!--chapter:end:05-structures.Rmd-->

# De Scripts a Funções e de Funções a Pacotes {#fx}

Em breve.

<!--chapter:end:06-functions.Rmd-->

# Geo Spatial: `raster`, `sf` e `stars` {#geo}

Em breve.

<!--chapter:end:07-geo-spatial.Rmd-->

`r if (knitr:::is_html_output()) '
# Referências {-}
'`

- [R Programming for Data Science (Leanpub)](https://leanpub.com/rprogramming)  
- [R Graphics Cookbook (Cookbook for R)](http://www.cookbook-r.com/Graphs/)  
- [An Introduction to R (CRAN)](https://cran.r-project.org/doc/manuals/r-release/R-intro.html)  
- [R Data Import/Export (CRAN)](https://cran.r-project.org/doc/manuals/r-release/R-data.html)  
- [RStudio Cheat Sheets (RStudio)](https://www.rstudio.com/resources/cheatsheets/)  
- [Webinars and Videos On Demand (RStudio)](https://www.rstudio.com/resources/webinars/)  
- [Online Learning (RStudio)](https://www.rstudio.com/online-learning/)  
- [Learn the tidyverse (Tidyverse)](https://www.tidyverse.org/learn/)
- [Writing R Extensions (CRAN)](https://cran.r-project.org/doc/manuals/r-release/R-exts.html)  
- [R Internals (CRAN)](https://cran.r-project.org/doc/manuals/r-release/R-ints.html)  
- [R Language Definition (CRAN)](https://cran.r-project.org/doc/manuals/r-release/R-lang.html)  

***
*Quer fazer um documento com o mesmo estilo do nosso? Leia* [bookdown: Authoring Books and Technical Documents with R Markdown (bookdown.org)](https://bookdown.org/yihui/bookdown/)

<!--chapter:end:08-references.Rmd-->


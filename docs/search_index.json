[
["index.html", "Curso de R para Meteorologia IAG/USP Capítulo 1 Pré-Requisitos 1.1 Sistema Operacional 1.2 Pacotes usados neste curso 1.3 Dados usados neste curso 1.4 Colaborar 1.5 Compartilhar dados", " Curso de R para Meteorologia IAG/USP Sergio Ibarra-Espinosa, Amanda Rehbein, Daniel Schuch, Camila Lopes, Isabela Siqueira, e possivelmente outros (você está convidado para colaborar) 2018-06-06 Capítulo 1 Pré-Requisitos 1.1 Sistema Operacional Antes de instalar o R na sua plataforma de interesse, verifique se há recomendações abaixo: Windows A princípio não há pré-requisitos! Caso fique entusiasmado com o R e queira desenvolver os próprios pacotes, instale o Rtools https://cran.r-project.org/bin/windows/Rtools/ Instale NetCDF, GDAL, GEOS, udunits e PROJ MacOS brew unlink gdal brew tap osgeo/osgeo4mac &amp;&amp; brew tap --repair brew install proj brew install geos brew install udunits brew install gdal2 --with-armadillo --with-complete --with-libkml --with-unsupported brew link --force gdal2 (Veja como instalar NetCDF no MacOS) Linux (Ubuntu e derivados) sudo add-apt-repository ppa:ubuntugis/ubuntugis-unstable --yes sudo apt-get --yes --force-yes update -qq # units/udunits2 dependency: sudo apt-get install --yes libudunits2-dev # sf dependencies: sudo apt-get install --yes libproj-dev libgeos-dev libgdal-dev libnetcdf-dev netcdf-bin gdal-bin 1.2 Pacotes usados neste curso Para fazer este curso instale os seguintes pacotes como indicado: check.packages &lt;- function(pkg){ new.pkg &lt;- pkg[!(pkg %in% installed.packages()[, &quot;Package&quot;])] if (length(new.pkg)) install.packages(new.pkg, dependencies = TRUE) sapply(pkg, require, character.only = TRUE) } # Usage example packages &lt;- c(&quot;devtools&quot;, &quot;tidyverse&quot;, &quot;reshape2&quot;, &quot;sf&quot;, &quot;maptools&quot;, &quot;mapview&quot;, &quot;fields&quot;, &quot;raster&quot;, &quot;sp&quot;, &quot;rgdal&quot;, &quot;ncdf4&quot;, &quot;data.table&quot;, &quot;openair&quot;, &quot;cptcity&quot;) check.packages(packages) devtools::install_github(&quot;atmoschem/veinreport&quot;) Fonte: https://gist.github.com/smithdanielle/9913897 Descrição de alguns desses pacotes: devtools permite a instalação de versões de desenvolvimento de pacotes de diferentes repositórios tidyverse é o universo de pacotes do Hadley Wickham para tratamento e visualização de dados Se você quiser plotar os objetos espaciais sf com o pacote ggplot2 (que faz parte do tidyverse), ele precisa ser instalado usando o devtools (devtools::install_github(&quot;tidyverse/ggplot2&quot;)), pois a função geom_sf ainda não está disponível na versão oficial sf, mapview, raster, sp, rgdal, maptools e fields tratam dados espaciais. Lembre-se que os objetos em Meteorologia são espaço-temporais ncdf4 é um pacote para manipular arquivos NetCDF openair é um pacote para trabalhar com dados de qualidade do ar e Meteorologia cptcity é um pacote que tem 7140 paletas de cores do arquivo web cpt-city Preste atenção na instalação dos pacotes pois eles podem precisar de dependências do sistema. 1.3 Dados usados neste curso Os exemplos mostrados neste curso usarão os dados que vocês podem baixar em: https://github.com/iagdevs/cursoR/tree/master/dados 1.4 Colaborar A melhor forma de colaboração é com pull requests no repositório do curso. Aplique o Guia de Estilo de R do Google ou o formato formatR. Em poucas palavras, lembre que seu código vai ser lido por seres humanos. É possível editar qualquer página usando um dos botões acima. 1.5 Compartilhar dados Se você conhece alguma fonte de dados para deixar este curso mais legal, edite este arquivo e faça um pull request. NCEP: ftp://nomads.ncdc.noaa.gov/GFS/analysis_only/ … … "],
["intro.html", "Capítulo 2 Intro 2.1 IMPORTANTE", " Capítulo 2 Intro Este curso é voltado para os alunos de pós-graduação, dessa forma, veremos os conceitos rapidamente. Caso não haja tempo, o conteúdo ficará online no link: https://github.com/iagdevs/cursoR. Sempre que tiver uma dúvida, tente utilizar: BASE. Outros pacotes BASE: utils, stats, datasets, graphics, grDevices, grid, methods, tools, parallel, compiler, splines, tcltk , stats4. Acesse aqui a lista de pacotes disponíveis. Este curso foi baseado no livro R Programming for Data Science e possui exercícios a serem resolvidos, perguntas que ajudam a entender conceitos e desafios para aprofundar os conhecimentos adquiridos. Neste curso iremos utilizar o software RStudio. A imagem abaixo resume um pouco das funcionalidades disponíveis. Fonte: RStudio IDE Cheatsheet Além de poder baixar o programa utilizado nesse curso, você também pode acessar muitos materiais como as Cheatsheets e Webnários que cobrem desde itens básicos como funções essenciais do RStudio até desenvolvimento de páginas para Web ou apps com Shiny. Explore o máximo que puder! Dicas: Se não souber usar uma função, escreva: ?função As funções tem argumentos, use TAB para vê-los numa função 2.1 IMPORTANTE TAB no RStudio Isso te ajudará a evitar coisas como: grafia errada da função, verificar se a função existe, verificar argumentos, etc… Use sempre! Stack Overflow (Veja as últimas das mais de 240000 (!!!) perguntas sobre R) Melhor forma de resolver problemas! Acredite, é praticamente impossível existir um problema que outra pessoa não tenha resolvido pelo Stack Overflow. Eu mesma só precisei fazer uma pergunta no Stack Overflow (e acabei respondendo eu mesma depois de resolver) usando R há uns 5 anos! - Camila. Vamos começar! "],
["r.html", "Capítulo 3 R! 3.1 Variáveis Básicas 3.2 Vetores 3.3 Classe 3.4 Converter objetos 3.5 Array 3.6 Matrizes e a função matrix 3.7 Listas 3.8 Data Frames 3.9 Tempo e Data 3.10 Fatores", " Capítulo 3 R! A linguagem R pode ser usada desde uma simples calculadora até uma poderosa ferramenta estatística, seja para análise de dados, seja para machine learning. Nesse capítulo veremos o básico da linguagem. Como a ideia é cobrir o máximo de conteúdo possível, passaremos bem rápido pelos conceitos básicos, com alguns exercícios para melhor entendimento. 3.1 Variáveis Básicas Podemos armazenar valores, strings ou operadores lógicos nas chamadas variáveis básicas. É com elas que podemos fazer operações básicas e transformar o RStudio em uma calculadora superpoderosa. Existem 5 tipos de variáveis básicas, sendo elas: Numeric (1): valores numéricos com ou sem casa decimal 5+2.3 ## [1] 7.3 pi ## [1] 3.141593 Character (a): com eles podemos armazenar strings, como o título de um gráfico titulo &lt;- &quot;Isso é uma string&quot; titulo ## [1] &quot;Isso é uma string&quot; Integer (1): são valores inteiros Complex (0+1i): também é possível armazenar valores complexos nas variáveis básicas 3 + 4i ## [1] 3+4i Logical (TRUE): são os famosos operadores Booleanos, que permitem realizar comparações entre variáveis ou dados (Você não pode criar uma variável com os nomes TRUE ou FALSE, esses nomes são reservados pelo R) 1 == 2 ## [1] FALSE 3.2 Vetores Vetores permitem que você armazene dados em uma sequência 1D de qualquer um dos tipos listados nas variáveis básicas, mais o formato “cru” (raw) que é o modo de armazenamento de bytes. Por exemplo: c(“A”, “C”, “D”) 1:5 = c(1, 2, 3, 4, 5) c(TRUE, FALSE) c(1i, -1i) Importante: ao contrário do C ou do Python, na linguagem R, a contagem das posições dos vetores começa do 1 e NÃO do zero! 3.3 Classe Como foi possível notar, todas as variáveis pertencem a alguma classe, dessa forma, a função class permite descobrir qual a classe da variável que se está utilizando: x &lt;- c(1,2,3) class(x) ## [1] &quot;numeric&quot; Exercício: Qual a classe dos seguintes vetores? c(1, “C”, “D”) c(1, NA, “D”) c(1, NA, NaN) 3.4 Converter objetos Às vezes quando trabalhamos com dados, podemos precisar “arredondar” valores ou converter vetores em listas, para isso existem algumas funções especiais. 3.4.1 as Um modo de forçar um objeto a assumir outra classe é por meio da função as: as.integer(c(1.5, 2.9, 1)) ## [1] 1 2 1 Note que a função apenas converte os números de decimais para inteiros, sem arredondar para o número mais próximo. Pergunta: O que acontece quando se tenta converter o seguinte vetor? as.numeric(c(1, &quot;C&quot;, &quot;D&quot;)) 3.4.2 merge e melt Nem sempre os conjuntos de dados que você encontrar pela vida estarão no formato desejado para plotar e/ou analisar estatisticamente, dessa forma, essas duas funções poderão ajudar na sua jornada: merge: permite a união entre dois data frames, seja por colunas em comum ou linhas em comum melt: do pacote reshape2, permite que você agrupe várias colunas em função de outra coluna em comum, de acordo com o nome especificado 3.5 Array Ao contrário do vetor unidimensional, arrays permietm que você armazene dados em diversas dimensões, sendo todas com o mesmo comprimento. Vamos dar uma olhada nos argumentos da função: args(array) ## function (data = NA, dim = length(data), dimnames = NULL) ## NULL Dessa forma, é preciso “informar” ao R qual o número de dimensões que você quer no seu array: a &lt;- array(data = 0, dim = c(1,1)) class(a) ## [1] &quot;matrix&quot; No caso acima, como só foram desiginadas duas dimensões, o array é igual a uma matriz. a &lt;- array(data = 0, dim = c(3,3,1)) class(a) ## [1] &quot;array&quot; Como dá pra ver acima, é possível armazenar diversos elementos em um array, como por exemplo as dimensões que utilizamos no dia-a-dia de modelos numéricos: espaço (x,y,z) e tempo (z). Dessa forma, podemos criar arrays a partir de vetores e armazená-los em diverssas dimensões. vetor1 &lt;- c(1,2,3,4,5) vetor2 &lt;- c(10,12,14,16,18,20,22,24) a &lt;- array(data = c(vetor1,vetor2), dim = c(3,3,2)) class(a) ## [1] &quot;array&quot; Se você quiser, também é possível nomear as colunas e linhas do seu array: colunas &lt;- c(&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;) linhas &lt;- c(&quot;lin1&quot;, &quot;lin2&quot;, &quot;lin3&quot;) array(data = c(vetor1, vetor2), dim = c(3, 3, 2), dimnames = list(linhas, colunas)) ## , , 1 ## ## col1 col2 col3 ## lin1 1 4 12 ## lin2 2 5 14 ## lin3 3 10 16 ## ## , , 2 ## ## col1 col2 col3 ## lin1 18 24 3 ## lin2 20 1 4 ## lin3 22 2 5 Além disso, sempre que precisar acessar elementos do seu array é só especificar aas dimensões como para mostrar o elemento de um vetor. a[1,2,2] #(linha, coluna, matriz) ## [1] 24 Exercício: Crie um array com 3 dimensões, contendo três linhas e 4 quatro colunas. Acesse o elemento da segunda linha e terceira coluna desse array. Não esqueça de verificar a classe desse objeto! 3.6 Matrizes e a função matrix Uma matriz é um array com duas dimensões, sendo necessário informar o número de colunas e linhas, mas não o de dimensões. Assim como em arrays, só são permitidos elementos da mesma clase! Argumentos da função matrix: args(matrix) ## function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) ## NULL Colocando dados em uma matriz: m1 &lt;- matrix(data = 1:(4*4), nrow = 4, ncol = 4) dim(m1) ## [1] 4 4 Por padrão, a opção “byrow” é igual a FALSE. Quando passamos para TRUE, é possível organizar os dados por linha. m2 &lt;- matrix(data = 1:(4*4), nrow = 4, ncol = 4, byrow = TRUE) Exercício: Construa uma matriz com três linhas que contenha os números de 1 a 9. 3.7 Listas Já as listas permitem que você armazene qualquer tipo de variável básica, independente da classe. Dessa forma, podemos colocar numa lista: número, caracteres, argumentos lógicos, ou que você quiser: list(list(list(list(1)))) ## [[1]] ## [[1]][[1]] ## [[1]][[1]][[1]] ## [[1]][[1]][[1]][[1]] ## [1] 1 Isso faz com que elas sejam bastante versáteis e sirvam para armazenar o que você precisar, mas elas só podem ter uma dimensão, como uma fila. Já os objetos armazenados dentro da lista não precisam ter a mesma dimensão. x &lt;- list(1, &quot;a&quot;, TRUE, 1 + 4i) Exercício: Crie uma lista contendo um vetor, uma matriz e um data frame e acesse o segundo elemento dela. Para facilitar, já vamos te dar o data frame: my_df &lt;- mtcars[1:10,] 3.8 Data Frames Os data frames são uma forma de armazenar seus dados em um formato parecido com uma planilha de excel. Você pode pensar em um data frame como uma matriz que armazena em cada coluna um dado diferente, ou como uma lista onde todos os elementos tem o mesmo comprimento. df &lt;- data.frame(a = 1:3) names(df) ## [1] &quot;a&quot; class(df) ## [1] &quot;data.frame&quot; mode(df) ## [1] &quot;list&quot; É normalmente em um data frame que você importará os seus dados e vale saber como visualizar algumas informações básicas sobre ele direto no seu console. Para isso, vamos pegar como exemplo o conjunto mtcars da base de dados do R: df &lt;- mtcars head(df) #mostra as sete primeiras linhas do data frame ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Para ver as últimas linhas do data frame basta usar a função tail. Já uma função muito útil é a summary, que apresenta um “resumo” dos seus dados, como média, mediana, mínimos e máximos para cada coluna do data frame. summary(df) ## mpg cyl disp hp ## Min. :10.40 Min. :4.000 Min. : 71.1 Min. : 52.0 ## 1st Qu.:15.43 1st Qu.:4.000 1st Qu.:120.8 1st Qu.: 96.5 ## Median :19.20 Median :6.000 Median :196.3 Median :123.0 ## Mean :20.09 Mean :6.188 Mean :230.7 Mean :146.7 ## 3rd Qu.:22.80 3rd Qu.:8.000 3rd Qu.:326.0 3rd Qu.:180.0 ## Max. :33.90 Max. :8.000 Max. :472.0 Max. :335.0 ## drat wt qsec vs ## Min. :2.760 Min. :1.513 Min. :14.50 Min. :0.0000 ## 1st Qu.:3.080 1st Qu.:2.581 1st Qu.:16.89 1st Qu.:0.0000 ## Median :3.695 Median :3.325 Median :17.71 Median :0.0000 ## Mean :3.597 Mean :3.217 Mean :17.85 Mean :0.4375 ## 3rd Qu.:3.920 3rd Qu.:3.610 3rd Qu.:18.90 3rd Qu.:1.0000 ## Max. :4.930 Max. :5.424 Max. :22.90 Max. :1.0000 ## am gear carb ## Min. :0.0000 Min. :3.000 Min. :1.000 ## 1st Qu.:0.0000 1st Qu.:3.000 1st Qu.:2.000 ## Median :0.0000 Median :4.000 Median :2.000 ## Mean :0.4062 Mean :3.688 Mean :2.812 ## 3rd Qu.:1.0000 3rd Qu.:4.000 3rd Qu.:4.000 ## Max. :1.0000 Max. :5.000 Max. :8.000 Iremos trabalhar bastante com data frames daqui pra frente, eles se tornarão aliados muito poderosos. 3.9 Tempo e Data O R trabalha com três classe de tempo: POSIXct, POSIXlt e Date, sendo que POSIXct se refere ao número de segundos desde o início de 1970 no modo UTC, enquanto que POSIXlt armazena as datas como uma lista, contendo segundos, minutos, horas, dias, meses, etc. a &lt;- ISOdate(year = 2018, month = 4, day = 5) class(a) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; b &lt;- ISOdate(year = 2018, month = 4, day = 5, tz = &quot;Americas/Sao_Paulo&quot;) ## Warning in strptime(x, &quot;%Y-%m-%d-%H-%M-%OS&quot;, tz = tz): unknown timezone ## &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(strptime(x, &quot;%Y-%m-%d-%H-%M-%OS&quot;, tz = tz), : ## unknown timezone &#39;Americas/Sao_Paulo&#39; Já a classe Date, armazena as datas como o número de dias contados a partir de 1970. c &lt;- as.Date(Sys.time()) class(c) ## [1] &quot;Date&quot; Caso você precise, o pacote nanotime permite trabalhar com nano segundos. Também é possível fazer sequências: hoje &lt;- Sys.time() a &lt;- seq.POSIXt(from = hoje, by = 3600, length.out = 24) Funções úteis: weekdays, month e julian weekdays(a) ## [1] &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; ## [5] &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; ## [9] &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; ## [13] &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; ## [17] &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; ## [21] &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; months(a) ## [1] &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; ## [9] &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; ## [17] &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; &quot;junho&quot; julian(a) #dia Juliano ## Time differences in days ## [1] 17688.13 17688.18 17688.22 17688.26 17688.30 17688.34 17688.38 ## [8] 17688.43 17688.47 17688.51 17688.55 17688.59 17688.63 17688.68 ## [15] 17688.72 17688.76 17688.80 17688.84 17688.88 17688.93 17688.97 ## [22] 17689.01 17689.05 17689.09 ## attr(,&quot;origin&quot;) ## [1] &quot;1970-01-01 GMT&quot; O formato POSIXct é o mais comumente usado principalmente se os dados analisados serão plotados. 3.10 Fatores Os factors podem ser um pouco infernais. Dê uma olhada em R INFERNO. Usados em análise estatísica, fatores são usados para armazenar variáveis categóricas, ou seja, é uma variável que pode pertencer a um número limitado de categorias, como por exemplo, dias da semana. Já uma variável contínua pode assumir um um número infinito de valores. a &lt;- seq.POSIXt(from = hoje , by = 3600, length.out = 24*7) aa &lt;- weekdays(a) class(aa) ## [1] &quot;character&quot; factor(aa) ## [1] quarta-feira quarta-feira quarta-feira quarta-feira quarta-feira ## [6] quarta-feira quarta-feira quarta-feira quarta-feira quarta-feira ## [11] quarta-feira quarta-feira quarta-feira quarta-feira quarta-feira ## [16] quarta-feira quarta-feira quarta-feira quarta-feira quarta-feira ## [21] quarta-feira quarta-feira quarta-feira quarta-feira quinta-feira ## [26] quinta-feira quinta-feira quinta-feira quinta-feira quinta-feira ## [31] quinta-feira quinta-feira quinta-feira quinta-feira quinta-feira ## [36] quinta-feira quinta-feira quinta-feira quinta-feira quinta-feira ## [41] quinta-feira quinta-feira quinta-feira quinta-feira quinta-feira ## [46] quinta-feira quinta-feira quinta-feira sexta-feira sexta-feira ## [51] sexta-feira sexta-feira sexta-feira sexta-feira sexta-feira ## [56] sexta-feira sexta-feira sexta-feira sexta-feira sexta-feira ## [61] sexta-feira sexta-feira sexta-feira sexta-feira sexta-feira ## [66] sexta-feira sexta-feira sexta-feira sexta-feira sexta-feira ## [71] sexta-feira sexta-feira sábado sábado sábado ## [76] sábado sábado sábado sábado sábado ## [81] sábado sábado sábado sábado sábado ## [86] sábado sábado sábado sábado sábado ## [91] sábado sábado sábado sábado sábado ## [96] sábado domingo domingo domingo domingo ## [101] domingo domingo domingo domingo domingo ## [106] domingo domingo domingo domingo domingo ## [111] domingo domingo domingo domingo domingo ## [116] domingo domingo domingo domingo domingo ## [121] segunda-feira segunda-feira segunda-feira segunda-feira segunda-feira ## [126] segunda-feira segunda-feira segunda-feira segunda-feira segunda-feira ## [131] segunda-feira segunda-feira segunda-feira segunda-feira segunda-feira ## [136] segunda-feira segunda-feira segunda-feira segunda-feira segunda-feira ## [141] segunda-feira segunda-feira segunda-feira segunda-feira terça-feira ## [146] terça-feira terça-feira terça-feira terça-feira terça-feira ## [151] terça-feira terça-feira terça-feira terça-feira terça-feira ## [156] terça-feira terça-feira terça-feira terça-feira terça-feira ## [161] terça-feira terça-feira terça-feira terça-feira terça-feira ## [166] terça-feira terça-feira terça-feira ## 7 Levels: domingo quarta-feira quinta-feira sábado ... terça-feira São muito úteis para regressões, gráficos e resumos estatísitcos, uma vez que limita o número de possibilidades para a qual o dado pertença. Além disso, é possível estabelecer “níveis” que vão designar a categoria do seu dado. ab &lt;- factor(x = aa, levels = c(&quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;, &quot;Sunday&quot;)) levels(ab) ## [1] &quot;Monday&quot; &quot;Tuesday&quot; &quot;Wednesday&quot; &quot;Thursday&quot; &quot;Friday&quot; &quot;Saturday&quot; ## [7] &quot;Sunday&quot; Exercício: Converta o vetor abaixo em um fator e mostre os seus níveis genero &lt;- c(&quot;Masculino&quot;, &quot;Masculino&quot;, &quot;Feminino&quot;, &quot;Masculino&quot;, &quot;Feminino&quot;, &quot;Feminino&quot;) Se tudo pareceu muito corrido, não se preocupe, todos esses conceitos serão praticados mais adiante! #-- Opção para deixar possível visualizar erros knitr::opts_chunk$set(error = TRUE) "],
["importando-e-exportando-dados.html", "Capítulo 4 Importando e Exportando Dados 4.1 Base 4.2 Tidyverse 4.3 Outros Tipos de Dados", " Capítulo 4 Importando e Exportando Dados 4.1 Base 4.1.1 Importando com read.* Como vimos anteriormente, na maioria dos casos, iremos usar data frames par lidar com dados em R, sendo assim, podemos utilizar os seguintes modos de leitura: read.csv read.csv2 read.table Vamos ler alguns dados usando read.table. Para saber o que a função faz, use ?read.table. Os argumentos da função são: args(read.table) ## function (file, header = FALSE, sep = &quot;&quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, ## numerals = c(&quot;allow.loss&quot;, &quot;warn.loss&quot;, &quot;no.loss&quot;), row.names, ## col.names, as.is = !stringsAsFactors, na.strings = &quot;NA&quot;, ## colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, ## fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE, ## comment.char = &quot;#&quot;, allowEscapes = FALSE, flush = FALSE, ## stringsAsFactors = default.stringsAsFactors(), fileEncoding = &quot;&quot;, ## encoding = &quot;unknown&quot;, text, skipNul = FALSE) ## NULL O terceiro argumento é sep, definido como &quot;&quot; por padrão. Esse argumento indica para o R qual o tipo de separador utilizado entre as colunas dos dados. df &lt;- read.table(&quot;dados/NOXIPEN2014.txt&quot;) Lembre-se que as funções head e tail permitem que você veja as primeiras ou últimas linhas do data frame. head(df) ## TipodeRede TipodeMonitoramento Tipo Data Hora ## 2 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 01:00 ## 3 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 02:00 ## 4 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 03:00 ## 5 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 04:00 ## 6 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 05:00 ## 7 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 06:00 ## CodigoEstaÃ.Ã.o NomeEstaÃ.Ã.o NomeParÃ.metro ## 2 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 3 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 4 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 5 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 6 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 7 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## UnidadedeMedida MediaHoraria MediaMovel Valido ## 2 ppb 9 - NÃ£o ## 3 ppb 9 - Sim ## 4 ppb 5 - Sim ## 5 ppb 4 - Sim ## 6 ppb 5 - Sim ## 7 ppb 5 - Sim tail(df) ## TipodeRede TipodeMonitoramento Tipo Data Hora ## 8577 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 19:00 ## 8578 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 20:00 ## 8579 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 21:00 ## 8580 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 22:00 ## 8581 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 23:00 ## 8582 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 24:00 ## CodigoEstaÃ.Ã.o NomeEstaÃ.Ã.o ## 8577 95 Cid.UniversitÃ¡ria-USP-Ipen ## 8578 95 Cid.UniversitÃ¡ria-USP-Ipen ## 8579 95 Cid.UniversitÃ¡ria-USP-Ipen ## 8580 95 Cid.UniversitÃ¡ria-USP-Ipen ## 8581 95 Cid.UniversitÃ¡ria-USP-Ipen ## 8582 95 Cid.UniversitÃ¡ria-USP-Ipen ## NomeParÃ.metro UnidadedeMedida MediaHoraria MediaMovel ## 8577 NOx (Ã“xidos de NitrogÃªnio) ppb 3 - ## 8578 NOx (Ã“xidos de NitrogÃªnio) ppb 8 - ## 8579 NOx (Ã“xidos de NitrogÃªnio) ppb 11 - ## 8580 NOx (Ã“xidos de NitrogÃªnio) ppb 11 - ## 8581 NOx (Ã“xidos de NitrogÃªnio) ppb 16 - ## 8582 NOx (Ã“xidos de NitrogÃªnio) ppb NA - ## Valido ## 8577 Sim ## 8578 Sim ## 8579 Sim ## 8580 Sim ## 8581 Sim ## 8582 Sim Vamos tentar ler outra versão dos mesmos dados utilizando a mesma função read.table: df2 &lt;- read.table(&quot;dados/NOXIPEN2014v2.txt&quot;) ## Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : linha 1 não tinha 6 elementos Apareceu uma mensagem de erro, você saberia dizer o porquê? Caso você trabalhe com algum banco de dados em formato .txt e quiser abrir no R… Abra-os no bloco de notas primeiro! Vamos dar uma olhada em alguns dados, o primeiro tem uma cara assim: Já o segundo arquivo é assim: Você notou a diferença? Como vimos anteriormente, para importar os dados no R é super importante que você especifique o tipo de separador utilizado. Como o segundo arquivo é separado por “;”, precisamos espercificar o argumento sep na hora de usar o comando read.table: df2 &lt;- read.table(&quot;dados/NOXIPEN2014v2.txt&quot;, sep = &quot;;&quot;) head(df2) ## TipodeRede TipodeMonitoramento Tipo Data Hora ## 2 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 01:00 ## 3 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 02:00 ## 4 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 03:00 ## 5 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 04:00 ## 6 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 05:00 ## 7 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 06:00 ## CodigoEstaÃ.Ã.o NomeEstaÃ.Ã.o NomeParÃ.metro ## 2 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 3 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 4 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 5 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 6 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 7 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## UnidadedeMedida MediaHoraria MediaMovel Valido ## 2 ppb 9 - NÃ£o ## 3 ppb 9 - Sim ## 4 ppb 5 - Sim ## 5 ppb 4 - Sim ## 6 ppb 5 - Sim ## 7 ppb 5 - Sim tail(df2) ## TipodeRede TipodeMonitoramento Tipo Data Hora ## 8577 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 19:00 ## 8578 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 20:00 ## 8579 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 21:00 ## 8580 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 22:00 ## 8581 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 23:00 ## 8582 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2015 24:00 ## CodigoEstaÃ.Ã.o NomeEstaÃ.Ã.o ## 8577 95 Cid.UniversitÃ¡ria-USP-Ipen ## 8578 95 Cid.UniversitÃ¡ria-USP-Ipen ## 8579 95 Cid.UniversitÃ¡ria-USP-Ipen ## 8580 95 Cid.UniversitÃ¡ria-USP-Ipen ## 8581 95 Cid.UniversitÃ¡ria-USP-Ipen ## 8582 95 Cid.UniversitÃ¡ria-USP-Ipen ## NomeParÃ.metro UnidadedeMedida MediaHoraria MediaMovel ## 8577 NOx (Ã“xidos de NitrogÃªnio) ppb 3 - ## 8578 NOx (Ã“xidos de NitrogÃªnio) ppb 8 - ## 8579 NOx (Ã“xidos de NitrogÃªnio) ppb 11 - ## 8580 NOx (Ã“xidos de NitrogÃªnio) ppb 11 - ## 8581 NOx (Ã“xidos de NitrogÃªnio) ppb 16 - ## 8582 NOx (Ã“xidos de NitrogÃªnio) ppb NA - ## Valido ## 8577 Sim ## 8578 Sim ## 8579 Sim ## 8580 Sim ## 8581 Sim ## 8582 Sim Além desses comandos, vocês também pode utilizar a opção Import Dataset do RStudio, permitindo que você tenha um “preview” dos dados - como no Excel, mas melhor! Para mais informações sobre importar dados no R, dê uma olha nesse webnário. 4.1.2 Exportando com write.table Exportar é bem facil. Vamos dar uma olhada nos argumentos da função write.table: args(write.table) ## function (x, file = &quot;&quot;, append = FALSE, quote = TRUE, sep = &quot; &quot;, ## eol = &quot;\\n&quot;, na = &quot;NA&quot;, dec = &quot;.&quot;, row.names = TRUE, col.names = TRUE, ## qmethod = c(&quot;escape&quot;, &quot;double&quot;), fileEncoding = &quot;&quot;) ## NULL Se temos um data frame com colunas de classe character, quote = TRUE quer dizer que o arquivo de texto resultante vai ter aspas nas colunas de caractere. Novamente, o argumento sep indica como podemos separar as colunas. Se você quiser abrir esses dados no excel, uma boa opção é utilizar os separadores “,”/“;”/&quot; “/”“, sendo o último o separador que indica o espaçamento criado pela tecla TAB. Já o argumento eol quer dizer end of line, e é uma forma de dizer ao R que a linha acaba ali. Por padrão, a opção row.names vem com a opção TRUE, mas sempre coloque a opção FALSE, caso contrário, será adicionada uma coluna com os índices das linhas. O argumento col.names indica se você quer nomear as suas colunas, o que é sempre uma boa ideia. Exercício: Usando o conjunto de dados mtcars da base do R, exporte-o de uma forma que ele possa ser lido em algum Excel genérico. Não esqueça de usar o que foi ensinado acima. 4.1.3 Exportando objetos com save Podemos salvar objetos do R com o comando save. Ele permite que você recarregue o objeto mais tarde. args(save) ## function (..., list = character(), file = stop(&quot;&#39;file&#39; must be specified&quot;), ## ascii = FALSE, version = NULL, envir = parent.frame(), compress = isTRUE(!ascii), ## compression_level, eval.promises = TRUE, precheck = TRUE) ## NULL Essa função salva o objeto com a extensão .rda sendo que para carregá-lo de volta usamos a função load args(load) ## function (file, envir = parent.frame(), verbose = FALSE) ## NULL Muito cuidado ao utilizar esse comando, pois é bem possível cometer alguns deslizes, como trocar o nome do objeto. Veja esse exemplo abaixo: #Primeiro vamos ler os dados do dia 01/06/2016 para uma estação automática do INMET de Paracatu: paracatu &lt;- read.csv(file = &quot;dados/paracatu.csv&quot;, sep = &quot;,&quot;) #lendo como csv # Vamos dizer que queremos salvar apenas a coluna correspondente à temperatura máxima horária: paracatu_temp &lt;- paracatu$temp_max #Agora vamos salvar o objeto do tipo numeric com o nome especificado: save(paracatu_temp, file = &quot;Temp_max.rda&quot;) Passado um tempo, queremos acessar de volta esse objeto, mas não lembramos se salvamos a temperatura máxima ou mínima, vamos confiar que foi a mínima: load(&quot;Temp_min.rda&quot;) E assim descobrimos que não era… O que nos ensina a sempre guardar na memória quais variáveis que salvamos no ambiente R. O bom dessa função é que ela permite salvar com tipos de compressão, por exemplo compress = &quot;xz&quot;. 4.1.4 Exportando objetos com saveRDS Esta é uma das minhas funçoes favoritas no R, veja só o porquê: saveRDS(paracatu_temp, &quot;Temperatura.rds&quot;) frenteQ &lt;- readRDS(&quot;Temperatura.rds&quot;) Você pode salvar seu objeto R de forma serializada e compactada com o argumento compress e na hora de chamar o objeto de volta é só usar readRDS e colocar o nome que você quiser. 4.1.5 Processando nossa data frame Vamos revisar a classe de cada coluna do nosso data-frame com a função sapply, que será explicada em outro capítulo. Lembre-se, qualquer dúvida é só usar ?sapply. sapply(df, class) ## TipodeRede TipodeMonitoramento Tipo ## &quot;factor&quot; &quot;factor&quot; &quot;factor&quot; ## Data Hora CodigoEstaÃ.Ã.o ## &quot;factor&quot; &quot;factor&quot; &quot;integer&quot; ## NomeEstaÃ.Ã.o NomeParÃ.metro UnidadedeMedida ## &quot;factor&quot; &quot;factor&quot; &quot;factor&quot; ## MediaHoraria MediaMovel Valido ## &quot;integer&quot; &quot;factor&quot; &quot;factor&quot; Quando trabalhamos com séries temporais, é importante ter a variável tempo reconhecida como “tempo”, especificamente como classe “POSIXct”. Porém, a classe do tipo Data é “factor” assim como a Hora, o que pode ser ruim. Então, vamos criar uma variável de tempo mais padronizada com o formato 2018-06-06 00:12:41. Para isso temos que juntar as variáveis Data e Hora. Faremos isso numa nova varável chamada “tempo_char”, adicionando-a diretamente no data frame com o cifrão (“$”). Podemos fazer isso com as funções paste ou paste0. df$tempo_char &lt;- paste(df$Data, df$Hora) head(df$tempo_char) ## [1] &quot;01/01/2014 01:00&quot; &quot;01/01/2014 02:00&quot; &quot;01/01/2014 03:00&quot; ## [4] &quot;01/01/2014 04:00&quot; &quot;01/01/2014 05:00&quot; &quot;01/01/2014 06:00&quot; class(df$tempo_char) ## [1] &quot;character&quot; Melhorou, mas ainda tem clase character. Para converter a nossa classe para POSIXct podemos usar a função as.POSIXct (olhe ?as.POSIXct). Seus argumentos são: args(as.POSIXct) ## function (x, tz = &quot;&quot;, ...) ## NULL Então, vamos criar outra variável tempo com o formato POSIXct: df$tempo &lt;- as.POSIXct(x = df$tempo_char, tz = &quot;Americas/Sao_Paulo&quot;, format = &quot;%d/%m/%Y %H:%M&quot;) ## Warning in strptime(x, format, tz = tz): unknown timezone &#39;Americas/ ## Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(as.POSIXlt(x, tz, ...), tz, ...): unknown ## timezone &#39;Americas/Sao_Paulo&#39; head(df$tempo) ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; ## [1] &quot;2014-01-01 01:00:00 GMT&quot; &quot;2014-01-01 02:00:00 GMT&quot; ## [3] &quot;2014-01-01 03:00:00 GMT&quot; &quot;2014-01-01 04:00:00 GMT&quot; ## [5] &quot;2014-01-01 05:00:00 GMT&quot; &quot;2014-01-01 06:00:00 GMT&quot; class(df$tempo) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; Agora, vamos extrair os dias da semana do tempo, mes e dia juliano: df$weekdays &lt;- format(df$tempo, &quot;%A&quot;) ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; head(df$weekdays) ## [1] &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; &quot;quarta-feira&quot; ## [5] &quot;quarta-feira&quot; &quot;quarta-feira&quot; df$mes &lt;- format(df$tempo, &quot;%B&quot;) ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; head(df$mes) ## [1] &quot;janeiro&quot; &quot;janeiro&quot; &quot;janeiro&quot; &quot;janeiro&quot; &quot;janeiro&quot; &quot;janeiro&quot; df$diajuliano &lt;- julian(df$tempo) head(df$diajuliano) ## Time differences in days ## [1] 16071.04 16071.08 16071.12 16071.17 16071.21 16071.25 df$ano &lt;- format(df$tempo, &quot;%Y&quot;) ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; Pronto! Agora temos o tempo no formato que desejamos. 4.1.5.1 aggregate Vamos dar uma olhada no nosso data frame: head(df) ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; ## TipodeRede TipodeMonitoramento Tipo Data Hora ## 2 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 01:00 ## 3 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 02:00 ## 4 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 03:00 ## 5 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 04:00 ## 6 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 05:00 ## 7 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 06:00 ## CodigoEstaÃ.Ã.o NomeEstaÃ.Ã.o NomeParÃ.metro ## 2 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 3 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 4 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 5 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 6 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 7 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## UnidadedeMedida MediaHoraria MediaMovel Valido tempo_char ## 2 ppb 9 - NÃ£o 01/01/2014 01:00 ## 3 ppb 9 - Sim 01/01/2014 02:00 ## 4 ppb 5 - Sim 01/01/2014 03:00 ## 5 ppb 4 - Sim 01/01/2014 04:00 ## 6 ppb 5 - Sim 01/01/2014 05:00 ## 7 ppb 5 - Sim 01/01/2014 06:00 ## tempo weekdays mes diajuliano ano ## 2 2014-01-01 01:00:00 quarta-feira janeiro 16071.04 days 2014 ## 3 2014-01-01 02:00:00 quarta-feira janeiro 16071.08 days 2014 ## 4 2014-01-01 03:00:00 quarta-feira janeiro 16071.12 days 2014 ## 5 2014-01-01 04:00:00 quarta-feira janeiro 16071.17 days 2014 ## 6 2014-01-01 05:00:00 quarta-feira janeiro 16071.21 days 2014 ## 7 2014-01-01 06:00:00 quarta-feira janeiro 16071.25 days 2014 Com a função aggregate, podemos agregar os dados de diversas formas. Por exemplo, a média horaria por dia da semana é: dff &lt;- aggregate(df$MediaHoraria, by = list(df$weekdays), mean, na.rm = T) names(dff) &lt;- c(&quot;dias&quot;, &quot;MediaHoraria&quot;) dff ## dias MediaHoraria ## 1 domingo 17.32907 ## 2 quarta-feira 34.07973 ## 3 quinta-feira 33.65931 ## 4 sábado 27.30178 ## 5 segunda-feira 28.93543 ## 6 sexta-feira 35.40599 ## 7 terça-feira 32.04057 E o desvio-padrão é: dff$sd &lt;- aggregate(df$MediaHoraria, by = list(df$weekdays), sd, na.rm = T)$x dff ## dias MediaHoraria sd ## 1 domingo 17.32907 22.11278 ## 2 quarta-feira 34.07973 41.26901 ## 3 quinta-feira 33.65931 42.14773 ## 4 sábado 27.30178 35.08044 ## 5 segunda-feira 28.93543 32.15303 ## 6 sexta-feira 35.40599 44.44488 ## 7 terça-feira 32.04057 33.87323 Exercício: Em média, como o NOx varia ao longo do dia de acordo com esses dados? Qual a amplitude diária? 4.1.5.2 subset Como podemos escolher só o mês de janeiro?? #[ LINHAS , COLUNAS ] head(df[df$mes == &quot;janeiro&quot;, ]) #TODAS AS COLUNAS ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; ## TipodeRede TipodeMonitoramento Tipo Data Hora ## 2 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 01:00 ## 3 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 02:00 ## 4 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 03:00 ## 5 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 04:00 ## 6 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 05:00 ## 7 AutomÃ¡tico CETESB Dados PrimÃ¡rios 01/01/2014 06:00 ## CodigoEstaÃ.Ã.o NomeEstaÃ.Ã.o NomeParÃ.metro ## 2 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 3 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 4 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 5 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 6 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## 7 95 Cid.UniversitÃ¡ria-USP-Ipen NOx (Ã“xidos de NitrogÃªnio) ## UnidadedeMedida MediaHoraria MediaMovel Valido tempo_char ## 2 ppb 9 - NÃ£o 01/01/2014 01:00 ## 3 ppb 9 - Sim 01/01/2014 02:00 ## 4 ppb 5 - Sim 01/01/2014 03:00 ## 5 ppb 4 - Sim 01/01/2014 04:00 ## 6 ppb 5 - Sim 01/01/2014 05:00 ## 7 ppb 5 - Sim 01/01/2014 06:00 ## tempo weekdays mes diajuliano ano ## 2 2014-01-01 01:00:00 quarta-feira janeiro 16071.04 days 2014 ## 3 2014-01-01 02:00:00 quarta-feira janeiro 16071.08 days 2014 ## 4 2014-01-01 03:00:00 quarta-feira janeiro 16071.12 days 2014 ## 5 2014-01-01 04:00:00 quarta-feira janeiro 16071.17 days 2014 ## 6 2014-01-01 05:00:00 quarta-feira janeiro 16071.21 days 2014 ## 7 2014-01-01 06:00:00 quarta-feira janeiro 16071.25 days 2014 Só que agora temos só a média horária para esse mês, que retorna um vetor numérico: names(df) ## [1] &quot;TipodeRede&quot; &quot;TipodeMonitoramento&quot; &quot;Tipo&quot; ## [4] &quot;Data&quot; &quot;Hora&quot; &quot;CodigoEstaÃ.Ã.o&quot; ## [7] &quot;NomeEstaÃ.Ã.o&quot; &quot;NomeParÃ.metro&quot; &quot;UnidadedeMedida&quot; ## [10] &quot;MediaHoraria&quot; &quot;MediaMovel&quot; &quot;Valido&quot; ## [13] &quot;tempo_char&quot; &quot;tempo&quot; &quot;weekdays&quot; ## [16] &quot;mes&quot; &quot;diajuliano&quot; &quot;ano&quot; head(df[df$mes == &quot;janeiro&quot;, 10]) ## [1] 9 9 5 4 5 5 head(df[df$mes == &quot;janeiro&quot;, &quot;MediaHoraria&quot;]) ## [1] 9 9 5 4 5 5 class(df[df$mes == &quot;janeiro&quot;, &quot;MediaHoraria&quot;]) ## [1] &quot;integer&quot; Exercício: Em média, como o NOx varia ao longo do dia em Julho? E em Dezembro? Vamos salvar nosso data frame para depois fazer gráficos: saveRDS(df, &quot;dados/df.rds&quot;) 4.1.6 Data.Table e mais O data.table é um pacote que apresenta a classe data.table, que é como uma versão melhorada da classe data.frame O termo especifico é que data.table tem um “parentesco” (inherits) com a classe data.frame. Vamos ver como funciona data.table lendo os dois arquivos e comparar quanto tempo demora cada um. A função de leitura do data.table é fread. df1 &lt;- print(system.time(read.table(&quot;dados/NOXIPEN2014.txt&quot;, h = T))) ## user system elapsed ## 0.09 0.00 0.09 library(data.table) df2 &lt;- print(system.time(fread(&quot;dados/NOXIPEN2014.txt&quot;, h = T))) ## user system elapsed ## 0.02 0.00 0.02 4.2 Tidyverse Um método mais recente (e muito interessante!) de tratar data frames é usando os pacotes dentro do Tidyverse. Usando diversas funções dos pacotes readr, tidyr e dplyr, por exemplo, é possível ler e processar dados de uma maneira mais user-friendly devido à sintaxe das funções e de como elas podem ser usadas em conjunto. Assim como o data.table tem uma classe própria, as funções dentro do tidyverse costumam trabalhar com sua própria classe, que é o tibble (ou tbl_df) - que segundo os desenvolvedores são data.frames preguiçosos e mal-humorados. Isso pode parecer ruim, mas na verdade é bom pois exige funções “mais espertas” para lidar com eles. Ainda assim é possível trabalhar com data frames sem dificuldades. Note que muitas das funções usadas abaixo podem ser encontradas em Base ou em outros pacotes associados. 4.2.1 Importando dados Todas as funções de leitura possuem a mesma estrutura: read_*(arquivo, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c(&quot;&quot;, &quot;NA&quot;), quoted_na = TRUE, comment = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = interactive()) Dica/Lembrete: Quando a descrição de uma função mostra os argumentos já definidos (col_names = TRUE), isso significa que esses são os valores padrão e que você não precisa escrever os argumentos se não quiser mudá-los Assim, todas as funções de leitura só precisam do nome do arquivo! Então como ler diferentes arquivos? Usando diferentes funções. read_csv lê arquivos .csv separados por \\(,\\) read_csv2 lê arquivos .csv separados por \\(;\\) read_delim lê arquivos com outros separadores (definidos com o argumento delim) read_fwf lê arquivos com delimitação fixa (definidos com o argumento col_positions) read_xl lê arquivos Excel (.xls e .xlsx) Assim, para ler os dados de Paracatu do INMET: library(tidyverse) paracatu &lt;- read_csv(&quot;dados/paracatu.csv&quot;) summary(paracatu) ## codigo_estacao data hora temp_inst ## Length:24 Length:24 Length:24 Min. :14.50 ## Class :character Class :character Class :character 1st Qu.:16.25 ## Mode :character Mode :character Mode :character Median :19.40 ## Mean :20.04 ## 3rd Qu.:24.32 ## Max. :26.40 ## temp_max temp_min umid_inst umid_max ## Min. :15.50 Min. :14.20 Length:24 Length:24 ## 1st Qu.:17.15 1st Qu.:15.38 Class :character Class :character ## Median :19.75 Median :18.15 Mode :character Mode :character ## Mean :20.78 Mean :19.26 ## 3rd Qu.:24.98 3rd Qu.:23.38 ## Max. :27.20 Max. :26.20 ## umid_min pto_orvalho_inst pto_orvalho_max ## Length:24 Length:24 Length:24 ## Class :character Class :character Class :character ## Mode :character Mode :character Mode :character ## ## ## ## pto_orvalho_min pressao pressao_max pressao_min ## Length:24 Min. :934.0 Min. :934.1 Min. :933.9 ## Class :character 1st Qu.:934.7 1st Qu.:934.8 1st Qu.:934.4 ## Mode :character Median :935.1 Median :935.4 Median :934.9 ## Mean :935.3 Mean :935.6 Mean :935.1 ## 3rd Qu.:935.6 3rd Qu.:936.0 3rd Qu.:935.4 ## Max. :937.6 Max. :937.7 Max. :937.4 ## vento_direcao vento_vel vento_rajada radiacao ## Min. :0.300 Min. : 14.00 Min. :0.80 Min. : -3.60 ## 1st Qu.:0.600 1st Qu.: 77.75 1st Qu.:1.85 1st Qu.: -3.60 ## Median :1.350 Median :209.00 Median :2.80 Median : 21.03 ## Mean :1.567 Mean :177.96 Mean :3.30 Mean : 713.77 ## 3rd Qu.:2.450 3rd Qu.:256.00 3rd Qu.:4.60 3rd Qu.:1483.50 ## Max. :4.100 Max. :355.00 Max. :6.70 Max. :2642.00 ## precipitacao ## Min. :0 ## 1st Qu.:0 ## Median :0 ## Mean :0 ## 3rd Qu.:0 ## Max. :0 4.2.2 Leitura %&gt;% Processamento Existem funções de leitura e modificação de data frames. Muitas vezes, você precisa lidar com dados “brutos” e que precisam de um certo processamento antes de serem utilizados em cálculos e gráficos. Como vimos anteriormente, isso exige no mínimo duas funções em duas linhas de código (uma para ler e outra para modificar), mas em geral esse processo precisa de bem mais do que isso. O operador %&gt;%) (chamada de pipe) está dentro do pacote magnittr (dentro do Tidyverse) e é muito útil nesse processo! (Leia um pouco sobre ele aqui) Como ele funciona? variável %&gt;% função1(., faz a modificação 1) %&gt;% função2(., faz a modificação 2) %&gt;% … %&gt;% funçãon(., faz a modificação n) O ponto (.) acima indica que a função será aplicada na versão da variável que chega nela. Em notação matemática, podemos dizer que \\(x \\ \\ \\%&gt;\\% \\ \\ f(y) = f(x,y)\\). Por exemplo, observe o código abaixo: library(&quot;tidyverse&quot;) seq(1, 10) %&gt;% order(., decreasing = T) %&gt;% paste(., &quot;n&quot;) ## [1] &quot;10 n&quot; &quot;9 n&quot; &quot;8 n&quot; &quot;7 n&quot; &quot;6 n&quot; &quot;5 n&quot; &quot;4 n&quot; &quot;3 n&quot; &quot;2 n&quot; &quot;1 n&quot; O vetor (que não precisa necessariamente ser definido como uma variável) é primeiro ordenado de forma decrescente e, a partir dessa modificação, é transformado em um vetor de caracteres ao colar a string “n” a ele. Uma forma de fazer isso sem usar %&gt;% seria: paste(order(seq(1, 10), decreasing = T), &quot;vezes&quot;) ## [1] &quot;10 vezes&quot; &quot;9 vezes&quot; &quot;8 vezes&quot; &quot;7 vezes&quot; &quot;6 vezes&quot; &quot;5 vezes&quot; ## [7] &quot;4 vezes&quot; &quot;3 vezes&quot; &quot;2 vezes&quot; &quot;1 vezes&quot; Pergunta: Na sua opinião, qual é o código mais fácil e rápido de ser entendido? Como isso pode ser aplicado a data frames? Voltando aos dados de Paracatu, vamos supor que você ainda não tenha lido esses dados, mas já saiba que o dia e a hora estão em colunas separadas e que você precisa juntá-los para calcular médias em períodos específicos. Além disso, você quer comparar a temperatura instantânea “temp_inst” com a média entre temperatura máxima “temp_max” e mínima “temp_min”. Então, precisamos: Ler os dados Juntas as colunas “data” e “hora” Transformar a coluna resultante em POSIXct Calcular a média entre “temp_max” e “temp_min” Comparar o que foi calculado com “temp_inst” Sem %&gt;%: library(tidyverse) paracatu &lt;- read_csv(&quot;dados/paracatu.csv&quot;) #-- 1. paracatu &lt;- mutate(paracatu, data_completa = paste(data, hora, sep = &quot;-&quot;)) #-- 2. paracatu &lt;- mutate(paracatu, data_completa = as.POSIXct(data_completa, format = &quot;%d/%m/%Y-%H&quot;)) #-- 3. paracatu &lt;- mutate(paracatu, temp_med = (temp_max + temp_min)/2) #-- 4. paracatu &lt;- mutate(paracatu, temp_residuo = temp_inst - temp_med) #-- 5. summary(paracatu) ## codigo_estacao data hora temp_inst ## Length:24 Length:24 Length:24 Min. :14.50 ## Class :character Class :character Class :character 1st Qu.:16.25 ## Mode :character Mode :character Mode :character Median :19.40 ## Mean :20.04 ## 3rd Qu.:24.32 ## Max. :26.40 ## temp_max temp_min umid_inst umid_max ## Min. :15.50 Min. :14.20 Length:24 Length:24 ## 1st Qu.:17.15 1st Qu.:15.38 Class :character Class :character ## Median :19.75 Median :18.15 Mode :character Mode :character ## Mean :20.78 Mean :19.26 ## 3rd Qu.:24.98 3rd Qu.:23.38 ## Max. :27.20 Max. :26.20 ## umid_min pto_orvalho_inst pto_orvalho_max ## Length:24 Length:24 Length:24 ## Class :character Class :character Class :character ## Mode :character Mode :character Mode :character ## ## ## ## pto_orvalho_min pressao pressao_max pressao_min ## Length:24 Min. :934.0 Min. :934.1 Min. :933.9 ## Class :character 1st Qu.:934.7 1st Qu.:934.8 1st Qu.:934.4 ## Mode :character Median :935.1 Median :935.4 Median :934.9 ## Mean :935.3 Mean :935.6 Mean :935.1 ## 3rd Qu.:935.6 3rd Qu.:936.0 3rd Qu.:935.4 ## Max. :937.6 Max. :937.7 Max. :937.4 ## vento_direcao vento_vel vento_rajada radiacao ## Min. :0.300 Min. : 14.00 Min. :0.80 Min. : -3.60 ## 1st Qu.:0.600 1st Qu.: 77.75 1st Qu.:1.85 1st Qu.: -3.60 ## Median :1.350 Median :209.00 Median :2.80 Median : 21.03 ## Mean :1.567 Mean :177.96 Mean :3.30 Mean : 713.77 ## 3rd Qu.:2.450 3rd Qu.:256.00 3rd Qu.:4.60 3rd Qu.:1483.50 ## Max. :4.100 Max. :355.00 Max. :6.70 Max. :2642.00 ## precipitacao data_completa temp_med ## Min. :0 Min. :2018-06-01 00:00:00 Min. :14.85 ## 1st Qu.:0 1st Qu.:2018-06-01 05:45:00 1st Qu.:16.21 ## Median :0 Median :2018-06-01 11:30:00 Median :18.90 ## Mean :0 Mean :2018-06-01 11:30:00 Mean :20.02 ## 3rd Qu.:0 3rd Qu.:2018-06-01 17:15:00 3rd Qu.:24.18 ## Max. :0 Max. :2018-06-01 23:00:00 Max. :26.70 ## temp_residuo ## Min. :-1.60000 ## 1st Qu.:-0.35000 ## Median : 0.02500 ## Mean : 0.02292 ## 3rd Qu.: 0.55000 ## Max. : 1.65000 Note que sempre se mostra necessário salvar cada passo em uma nova variável ou, nesse caso, reciclar a mesma variável. Foi preciso uma linha para cada operação. Já com %&gt;%: library(tidyverse) paracatu &lt;- read_csv(&quot;dados/paracatu.csv&quot;) %&gt;% #-- 1. mutate(., data_completa = paste(data, hora, sep = &quot;-&quot;)) %&gt;% #-- 2. mutate(., data_completa = as.POSIXct(data_completa, format = &quot;%d/%m/%Y-%H&quot;)) %&gt;% #-- 3. mutate(., temp_med = (temp_max + temp_min)/2) %&gt;% #-- 4. mutate(., temp_residuo = temp_inst - temp_med) #-- 5. summary(paracatu) ## codigo_estacao data hora temp_inst ## Length:24 Length:24 Length:24 Min. :14.50 ## Class :character Class :character Class :character 1st Qu.:16.25 ## Mode :character Mode :character Mode :character Median :19.40 ## Mean :20.04 ## 3rd Qu.:24.32 ## Max. :26.40 ## temp_max temp_min umid_inst umid_max ## Min. :15.50 Min. :14.20 Length:24 Length:24 ## 1st Qu.:17.15 1st Qu.:15.38 Class :character Class :character ## Median :19.75 Median :18.15 Mode :character Mode :character ## Mean :20.78 Mean :19.26 ## 3rd Qu.:24.98 3rd Qu.:23.38 ## Max. :27.20 Max. :26.20 ## umid_min pto_orvalho_inst pto_orvalho_max ## Length:24 Length:24 Length:24 ## Class :character Class :character Class :character ## Mode :character Mode :character Mode :character ## ## ## ## pto_orvalho_min pressao pressao_max pressao_min ## Length:24 Min. :934.0 Min. :934.1 Min. :933.9 ## Class :character 1st Qu.:934.7 1st Qu.:934.8 1st Qu.:934.4 ## Mode :character Median :935.1 Median :935.4 Median :934.9 ## Mean :935.3 Mean :935.6 Mean :935.1 ## 3rd Qu.:935.6 3rd Qu.:936.0 3rd Qu.:935.4 ## Max. :937.6 Max. :937.7 Max. :937.4 ## vento_direcao vento_vel vento_rajada radiacao ## Min. :0.300 Min. : 14.00 Min. :0.80 Min. : -3.60 ## 1st Qu.:0.600 1st Qu.: 77.75 1st Qu.:1.85 1st Qu.: -3.60 ## Median :1.350 Median :209.00 Median :2.80 Median : 21.03 ## Mean :1.567 Mean :177.96 Mean :3.30 Mean : 713.77 ## 3rd Qu.:2.450 3rd Qu.:256.00 3rd Qu.:4.60 3rd Qu.:1483.50 ## Max. :4.100 Max. :355.00 Max. :6.70 Max. :2642.00 ## precipitacao data_completa temp_med ## Min. :0 Min. :2018-06-01 00:00:00 Min. :14.85 ## 1st Qu.:0 1st Qu.:2018-06-01 05:45:00 1st Qu.:16.21 ## Median :0 Median :2018-06-01 11:30:00 Median :18.90 ## Mean :0 Mean :2018-06-01 11:30:00 Mean :20.02 ## 3rd Qu.:0 3rd Qu.:2018-06-01 17:15:00 3rd Qu.:24.18 ## Max. :0 Max. :2018-06-01 23:00:00 Max. :26.70 ## temp_residuo ## Min. :-1.60000 ## 1st Qu.:-0.35000 ## Median : 0.02500 ## Mean : 0.02292 ## 3rd Qu.: 0.55000 ## Max. : 1.65000 O código pode estar separado por linhas, mas perceba que, ao rodar qualquer linha desse conjunto, todo ele é rodado de uma vez! Assim, adicionar um passo fica fácil. Por exemplo, as colunas “data” e “hora” não são mais necessárias: library(tidyverse) paracatu &lt;- read_csv(&quot;dados/paracatu.csv&quot;) %&gt;% #-- 1. mutate(., data_completa = paste(data, hora, sep = &quot;-&quot;)) %&gt;% #-- 2. mutate(., data_completa = as.POSIXct(data_completa, format = &quot;%d/%m/%Y-%H&quot;)) %&gt;% #-- 3. mutate(., temp_med = (temp_max + temp_min)/2) %&gt;% #-- 4. mutate(., temp_residuo = temp_inst - temp_med) %&gt;% #-- 5. select(., -c(data, hora)) #-- 6. summary(paracatu) ## codigo_estacao temp_inst temp_max temp_min ## Length:24 Min. :14.50 Min. :15.50 Min. :14.20 ## Class :character 1st Qu.:16.25 1st Qu.:17.15 1st Qu.:15.38 ## Mode :character Median :19.40 Median :19.75 Median :18.15 ## Mean :20.04 Mean :20.78 Mean :19.26 ## 3rd Qu.:24.32 3rd Qu.:24.98 3rd Qu.:23.38 ## Max. :26.40 Max. :27.20 Max. :26.20 ## umid_inst umid_max umid_min ## Length:24 Length:24 Length:24 ## Class :character Class :character Class :character ## Mode :character Mode :character Mode :character ## ## ## ## pto_orvalho_inst pto_orvalho_max pto_orvalho_min pressao ## Length:24 Length:24 Length:24 Min. :934.0 ## Class :character Class :character Class :character 1st Qu.:934.7 ## Mode :character Mode :character Mode :character Median :935.1 ## Mean :935.3 ## 3rd Qu.:935.6 ## Max. :937.6 ## pressao_max pressao_min vento_direcao vento_vel ## Min. :934.1 Min. :933.9 Min. :0.300 Min. : 14.00 ## 1st Qu.:934.8 1st Qu.:934.4 1st Qu.:0.600 1st Qu.: 77.75 ## Median :935.4 Median :934.9 Median :1.350 Median :209.00 ## Mean :935.6 Mean :935.1 Mean :1.567 Mean :177.96 ## 3rd Qu.:936.0 3rd Qu.:935.4 3rd Qu.:2.450 3rd Qu.:256.00 ## Max. :937.7 Max. :937.4 Max. :4.100 Max. :355.00 ## vento_rajada radiacao precipitacao ## Min. :0.80 Min. : -3.60 Min. :0 ## 1st Qu.:1.85 1st Qu.: -3.60 1st Qu.:0 ## Median :2.80 Median : 21.03 Median :0 ## Mean :3.30 Mean : 713.77 Mean :0 ## 3rd Qu.:4.60 3rd Qu.:1483.50 3rd Qu.:0 ## Max. :6.70 Max. :2642.00 Max. :0 ## data_completa temp_med temp_residuo ## Min. :2018-06-01 00:00:00 Min. :14.85 Min. :-1.60000 ## 1st Qu.:2018-06-01 05:45:00 1st Qu.:16.21 1st Qu.:-0.35000 ## Median :2018-06-01 11:30:00 Median :18.90 Median : 0.02500 ## Mean :2018-06-01 11:30:00 Mean :20.02 Mean : 0.02292 ## 3rd Qu.:2018-06-01 17:15:00 3rd Qu.:24.18 3rd Qu.: 0.55000 ## Max. :2018-06-01 23:00:00 Max. :26.70 Max. : 1.65000 Pergunta: E agora? Na sua opinião, qual é o código mais fácil e rápido de ser entendido? Exercício: Crie um data frame dos dados de Paracatu com a data no formato POSIXct e os resíduos de temperatura, umidade e pressão. Em geral, qual grandeza tem maior resíduo? 4.3 Outros Tipos de Dados 4.3.1 NetCDF O NetCDF (Network Common Data Form) é um conjunto de bibliotecas de software e formatos de dados independentes de máquina e autodescritivos com suporte para criação, acesso e compartilhamento de dados científicos orientados a matrizes. Arquivos NetCDF (criado por essa biblioteca ou por programas que utilizam essa biblioteca) são arquivos compostos por dados, atributos e metadados. O pacote ncdf4 é um exemplo de interface do R com a biblioteca NetCDF 4, os comandos abaixo instalam e carregam esse pacote: #install.packages(&quot;ncdf4&quot;) # instala o pacote library(&quot;ncdf4&quot;) # carrega o pacote nc_version() # versão da biblioteca ## [1] &quot;ncdf4_1.16_20170401&quot; Um exemplo de NetCDF: edgar &lt;- nc_open(filename = &quot;dados/v431_v2_REFERENCE_CO_2010_10_AGR.0.1x0.1.nc&quot;) O objeto edgar contém algumas informações sobre o conteúdo do arquivo, com um print(edgar) ou simplesmente edgar visualizamos o conteúdo do arquivo: class(edgar) edgar Isso mostra o nome do arquivo (e versão da biblioteca usada para criar), número de variáveis (1 variável neste exemplo), uma descrição de cada variável (incluindo atributos) as dimensões (2 para esse arquivo) e atributos globais. Agora vamos abrir alguma variável: names(edgar$var) co &lt;- ncdf4::ncvar_get(edgar, &quot;emi_co&quot;) class(co) Como o NetCDF é organizado para guardar matrizes (arrays), só sabemos que a variável emi_co é um array ncatt_get(edgar,&quot;emi_co&quot;) # ou ncatt_get(edgar,&quot;emi_co&quot;,verbose = T) repete a informação do print anterior, mas sem os atributos globais: # $standard_name # [1] &quot;tendency_of_atmosphere_mass_content_of_carbon_monoxide_due_to_emission&quot; # $long_name # [1] &quot;Emissions of CO - &quot; # $units # [1] &quot;kg m-2 s-1&quot; # $cell_method # [1] &quot;time: mean (interval: 1 month, 31 days)&quot; # $total_emi_co # [1] &quot; 6.32889e+009 kg/month&quot; # $comment # [1] &quot; (see http://edgar.jrc.ec.europa.eu/methodology.php#12sou for the definitions of the single sources)&quot; A latitude de cada ponto de grade, assim como longitude níveis (tempo em outros casos) o podem ser extraídas: lat &lt;- ncvar_get(wrf, &quot;lat&quot;) lon &lt;- ncvar_get(wrf, &quot;lon&quot;) O metadado de Longitude também pode conter informações úteis: ncatt_get(edgar,&quot;lon&quot;) # $standard_name # [1] &quot;longitude&quot; # $long_name # [1] &quot;longitude&quot; # $units # [1] &quot;degrees_east&quot; # $comment # [1] &quot;center_of_cell&quot; e Latitude: ncatt_get(edgar,&quot;lat&quot;) # $standard_name # [1] &quot;latitude&quot; # $long_name # [1] &quot;latitude&quot; # $units # [1] &quot;degrees_north&quot; # $comment # [1] &quot;center_of_cell&quot; e também os atributos globais podem ser acessados separadamante: ncatt_get(edgar,varid = 0) # $Conventions # [1] &quot;CF-1.0&quot; # $title # [1] &quot;Monthly Mean (October) Emissions of CO - &quot; # $institution # [1] &quot;European Commission, Joint Research Centre&quot; # $source # [1] &quot;http://edgar.jrc.ec.europa.eu/&quot; # $history # [1] &quot;Created from original data (0.1x0.1 degrees) using IDL program (edgar_ascii_to_ncdf.pro) on Wed Jun 29 13:29:58 2016&quot; # $references # [1] &quot;European Commission, Joint Research Centre (JRC)/Netherlands Environmental Assessment Agency (PBL). Emission Database for Global Atmospheric Research (EDGAR),http://edgar.jrc.ec.europe.eu&quot; # $copyright_notice # [1] &quot;Reproduction of the data is authorized, except for commercial purposes, provided the source is fully acknowledged in the from\\&quot;Source: European Commission, Joint Research Centre (JRC)/Netherlands Environmental Assessment Agency (PBL). Emission Databasefor Global Atmospheric Research (EDGAR), http://edgar.jrc.ec.europe.eu\\&quot;. Where reproduction is on a web-site,at least one link to http://edgar.jrc.ec.europa.eu, should be provided and maintained. Where prior permission must be obtained for thereproduction or use of textual and multimedia information (sound, images, software, etc.), such permission shall cancel the above-mentionedgeneral permission and shall clearly indicate any restrictions on use.&quot; # $contact # [1] &quot;edgar-info@jrc.ec.europa.eu&quot; Da mesma forma com que podemos acessar variáveis e atributos com ncvar_get e ncatt_get, podemos modificar estes valores com ncvar_put e ncatt_put. Outras operações como renomear (ncvar_rename) e trocar o valor de missval (ncvar_change_missval) também estão disponíveis. DICA: ncatt_get e ncatt_put acessam e alteram os atributos de váriaveis e também atributos globais do NetCDF usando o argumento varid=0 como no código mostrado anteriormente. Para salvar as alterações e/ou liberar o acesso ao arquivo use a função nc_close (ou a função nc_sync que sincroniza o NetCDF mas não fecha a conexão com o arquivo). nc_close(edgar) # ou nc_sync(edgar) O pacote possue ainda funções mais específicas para a criação de arquivos em NetCDF como nc_create, funções que definem dimenções como ncdim_def e funções para colocar e tirar o arquivo de modo de definição nc_redef e nc_enddef. DICA: o NetCDF no R funciona de forma parecida com ouma lista ou data frame, podemos “ver” ou selecionar suas sub-partes (sub-sub-partes…) com “$” e TAB. 4.3.2 Dados Binários O R lê e escreve dados binários usando as funções readBin e writeBin, respectivamente. Ler dados binários no R Em meteorologia, frequentemente os dados estão em formato binário. A maior “dificuldade” em ler estes dados está em conhecer como eles foram gerados. Neste curso, o arquivo binário que vamos abrir como exemplo contém dados de temperatura de brilho obtidas com o satélite GOES-13 (informações em: https://disc.gsfc.nasa.gov/datasets/GPM_MERGIR_1/summary). Lembrem-se de baixar o dado em: https://github.com/iagdevs/cursoR/tree/master/dados Repare que a função readBin requer alguns argumentos para ler estes dados da forma correta: args(readBin) ## function (con, what, n = 1L, size = NA_integer_, signed = TRUE, ## endian = .Platform$endian) ## NULL # Lembre-se de usar ?readBin O que são estes argumentos? con é um objeto de conexão ou um string de caracteres nomeando um arquivo. what é um string de caracteres que indica o modo dos dados a serem lidos. Pode ser um “numeric”, “double”, “integer”, “int”, “logical”, “complex”, or “character”. n um inteiro especificando o número máximo de valores a serem lidos. size um inteiro especificando o número de bytes por valor lido. O padrão de NA_integer_ usa um tamanho padrão para um valor do modo (what) especificado (4 para “integer”, 8 para “double” e 16 para “complex”. Este argumento é ignorado para dados “character”. Neste caso, os dados de caracteres são lidos como sequências de caracteres de byte único terminadas em nulo. signed é um valor lógico. Usado apenas para números “integer” de tamanhos 1 e 2. Se TRUE (por default), “integers” são considerados como números inteiros assinados. endian é um string de caracteres. Se endian = “big” ou se endian = “little”, especifica-se a extremidade (endian-ness) dos valores lidos ou escritos. Se endian=“swap” a extremidade é trocada. Hardware Intel é “little” endian e hardware Sun é “big” endian. # Ler o arquivo binário: readBin l1 &lt;- readBin(&quot;dados/gs.140422.1900g.ch4&quot;, what=&quot;int&quot;, n = 1349*1613, size = 2, signed = T, endian = &quot;little&quot;) class(l1) ## [1] &quot;integer&quot; Uma forma rápida para verificarmos os nossos dados é gráfica. Logo, que tal um plot? l2 &lt;- matrix(l1, ncol=1613, nrow=1349) class(l2) ## [1] &quot;matrix&quot; # Vamos chamar o pacote cptcity para selecionar facilmente uma paleta de cores legal. library(cptcity) image(l2, col = cpt(find_cpt(&quot;sat&quot;)[8]), main = &quot;Temperatura de brilho&quot;) Tem algo estranho com esta imagem. O que é? (valendo um sticker). library(raster, quietly = TRUE) l3 &lt;- raster(t(l2[1:1349,1:1613]), xmn=-82.00, ymn=-44.96, xmx=-82.0 + (0.03593245*1349), ymx=-44.96 + (0.03593245*1613), crs = CRS(&quot;+init=epsg:4326&quot;)) class(l3) ## [1] &quot;RasterLayer&quot; ## attr(,&quot;package&quot;) ## [1] &quot;raster&quot; O capítulo geoespacial será visto no final deste curso. Porém, nesta etapa vamos usar o pacote raster somente para analisar se os dados binários foram lidos corretamente. sp::spplot(((l3 + 75)/100)-273, # Estas correções são necessárias. Veja: http://www.cpc.ncep.noaa.gov/products/global_precip/html/README col.regions = cpt(find_cpt(&quot;sat&quot;)[8]), at = seq(-80,0,1), main = &quot;Temperatura de brilho (ºC)&quot;) Escrever dados binários no R # Escrever um arquivo binário: writeBin args(writeBin) ## function (object, con, size = NA_integer_, endian = .Platform$endian, ## useBytes = FALSE) ## NULL # Lembre-se de usar ?writeBin useBytes um valor lógico. No R, se FALSE (o default), especifica que writeBin converteria strings com codificações para uma string imprimível antes de escrever os bytes. Se TRUE, especifica que writeBin escreveria os bytes do string não convertidos. object um objeto escrito no con. # Na linha abaixo vamos criar um arquivo temporário com o auxílio da função &quot;tempfile&quot; # para depois escrever os dados dentro deste arquivo. tf &lt;- tempfile() # Vamos atribuir a &quot;tb&quot; os 20 primeiros valores de l1 (temperatura de brilho). tb &lt;- c(21000, 21000, 20800, 21000, 20800, 20700, 20600, 20600, 20900, 20900, 20900, 20900, 20700, 20500, 20500, 20400, 20500, 20700, 20400, 20300) class(tb) ## [1] &quot;numeric&quot; x &lt;- as.integer(tb) writeBin(x, con = tf) # Agora vamos ler o arquivo binário escrito acima. Você lembra quais são os argumentos para ler binário? readBin(tf, what = &quot;integer&quot;, n = 20) ## [1] 21000 21000 20800 21000 20800 20700 20600 20600 20900 20900 20900 ## [12] 20900 20700 20500 20500 20400 20500 20700 20400 20300 "],
["plotando.html", "Capítulo 5 Plotando 5.1 plot (base) 5.2 ggplot (ggplot2)", " Capítulo 5 Plotando 5.1 plot (base) Exemplo: Dados de qualidade do ar df &lt;- readRDS(&quot;dados/df.rds&quot;) summary(df) ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; ## TipodeRede TipodeMonitoramento Tipo ## AutomÃ¡tico:8581 CETESB:8581 Dados PrimÃ¡rios:8581 ## ## ## ## ## ## ## Data Hora CodigoEstaÃ.Ã.o ## 01/01/2014: 24 16:00 : 363 Min. :95 ## 01/01/2015: 24 12:00 : 361 1st Qu.:95 ## 01/02/2014: 24 14:00 : 361 Median :95 ## 01/04/2014: 24 18:00 : 361 Mean :95 ## 01/05/2014: 24 13:00 : 360 3rd Qu.:95 ## 01/06/2014: 24 17:00 : 360 Max. :95 ## (Other) :8437 (Other):6415 ## NomeEstaÃ.Ã.o NomeParÃ.metro ## Cid.UniversitÃ¡ria-USP-Ipen:8581 NOx (Ã“xidos de NitrogÃªnio):8581 ## ## ## ## ## ## ## UnidadedeMedida MediaHoraria MediaMovel Valido ## ppb:8581 Min. : 0.00 -:8581 NÃ£o: 907 ## 1st Qu.: 9.00 Sim :7674 ## Median : 18.00 ## Mean : 29.87 ## 3rd Qu.: 34.00 ## Max. :306.00 ## NA&#39;s :260 ## tempo_char tempo weekdays ## Length:8581 Min. :2014-01-01 01:00:00 Length:8581 ## Class :character 1st Qu.:2014-04-05 14:00:00 Class :character ## Mode :character Median :2014-07-05 23:00:00 Mode :character ## Mean :2014-07-04 20:22:55 ## 3rd Qu.:2014-10-03 10:00:00 ## Max. :2015-01-02 00:00:00 ## ## mes diajuliano ano ## Length:8581 Length:8581 Length:8581 ## Class :character Class :difftime Class :character ## Mode :character Mode :numeric Mode :character ## ## ## ## A função plot precisa dos seguintes argumentos: args(plot) ## function (x, y, ...) ## NULL Então, a forma mais fácil de plotar uma variável em função do tempo é: plot(x = df$tempo, y = df$MediaHoraria) ## Warning in as.POSIXlt.POSIXct(z): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(zz): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; Feio, né? Tentando deixar mais bonito… plot(x = df$tempo[1:100], y = df$MediaHoraria[1:100], #-- Selecionando uma parte do df! pch = 16, #-- Forma do ponto (círculo preenchido) type = &quot;b&quot;, #-- Tipo de gráfico (&quot;b&quot; = both, ponto e linha) col = &quot;blue&quot;, #-- Cor do elemento (definido pelo type) xlab = &quot;Data&quot;, ylab = &quot;NOx [ppb]&quot;, #-- Nome dos eixos x e y main = &quot;Gráfico mais Bonito&quot;) #-- Título do gráfico ## Warning in as.POSIXlt.POSIXct(x): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(round(z, &quot;days&quot;)): unknown timezone ## &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; Colocando DOIS elementos no mesmo gráfico: df_parcial &lt;- df[1:180,] #-- Selecionando uma parte do df! plot(x = df_parcial$tempo[df_parcial$Valido == &quot;Sim&quot;], y = df_parcial$MediaHoraria[df_parcial$Valido == &quot;Sim&quot;], pch = 16, type = &quot;b&quot;, col = &quot;blue&quot;, xlab = &quot;Data&quot;, ylab = &quot;NOx [ppb]&quot;, main = &quot;Dados Válidos e Inválidos&quot;) ## Warning in as.POSIXlt.POSIXct(x): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(round(z, &quot;days&quot;)): unknown timezone ## &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; lines(x = df_parcial$tempo[df$Valido == &quot;Não&quot;], y = df_parcial$MediaHoraria[df$Valido == &quot;Não&quot;], pch = 15, type = &quot;b&quot;, col = &quot;red&quot;) Desafio: Coloque uma legenda na figura especificando que os dados válidos estão em azul e os inválidos em vermelho A função plot cumpre bem o papel de gerar um gráfico simples, e até permite algumas customizações, mas ela exige cada vez mais linhas de código e argumentos dentro das funções para deixar o gráfico “mais bonito” - ao cumprir o desafio, você irá perceber como uma coisa “simples” como colocar uma legenda pode exigir muito mais do que parece! 5.2 ggplot (ggplot2) A função ggplot funciona de um jeito um pouco diferente. Veja a figura abaixo: Fonte: https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf Em vez de uma única função, o gráfico é formado por camadas, sendo que cada camada é um elemento (geom_... ou stat_...) ou configuração (scale_..._..., coord_..., theme ou theme_..., guides, labs, etc). Consulte a maioria das opções disponíveis em Data Visualization Cheatsheet. Que tal refazermos os gráficos da seção anterior? #-- Não esqueça de carregar o pacote! library(ggplot2) ggplot(df, aes(x = tempo, y = MediaHoraria)) + geom_point(pch = 1) ## Warning in as.POSIXlt.POSIXct(x): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(to): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(x): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(to): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning: Removed 260 rows containing missing values (geom_point). ggplot(df[1:100,], aes(x = tempo, y = MediaHoraria)) + geom_line(color = &quot;blue&quot;) + #-- Linhas... geom_point(color = &quot;blue&quot;, pch = 16) + #-- ... com pontos labs(title = &quot;Gráfico mais Bonito&quot;, x = &quot;Data&quot;, y = &quot;NOx [ppb]&quot;) + #-- Títulos theme(plot.title = element_text(hjust = 0.5)) #-- Centralizando o título ## Warning in as.POSIXlt.POSIXct(x): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(x): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; Agora o mais interessante: ggplot(df[1:180,], aes(x = tempo, y = MediaHoraria)) + geom_line(aes(color = Valido)) + geom_point(aes(color = Valido, shape = Valido)) + labs(title = &quot;Dados Válidos e Inválidos&quot;, x = &quot;Data&quot;, y = &quot;NOx [ppb]&quot;) + scale_color_manual(values = c(&quot;red&quot;, &quot;blue&quot;)) + #-- Definindo as cores manualmente scale_shape_manual(values = c(15, 16)) + #-- Definindo as formas manualmente theme(plot.title = element_text(hjust = 0.5)) ## Warning in as.POSIXlt.POSIXct(x): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; Pergunta: Qual a principal diferença entre o código acima e o código usando plot? A função ggplot plota apenas data frames, pois ela mapeia as variáveis por nomes de colunas. Assim, é preciso converter matrizes ou arrays em data frames. Uma vantagem de trabalharmos com data frames, como já vimos antes, é poder manipular esses dados de muitas formas possíveis antes de plotá-los. Continuação do Exemplo: Extraindo algumas informações sobre os dados Vamos analisar o ano de 2014: Em média, como o NOx varia ao longo do dia? E para cada dia da semana? E para cada mês? Usando algumas outras funções dentro do Tidyverse: library(tidyverse) df_2014 &lt;- filter(df, ano == &quot;2014&quot;) df_2014_hour &lt;- df_2014 %&gt;% #-- A partir do data frame df_2014 group_by(Hora) %&gt;% #-- Agrupe os dados pela coluna hora summarise(Media = mean(MediaHoraria, na.rm = T)) %&gt;% #-- E calcule as médias, #-- salvando em uma coluna nova mutate(Hora = as.POSIXct(strptime(Hora, &quot;%H:%M&quot;))) %&gt;% #-- Transformando em data ungroup() #-- Desagrupando ggplot(df_2014_hour) + scale_x_datetime(date_labels = &quot;%H:%M&quot;) + #-- Formato de data que aparecerá no eixo x geom_line(aes(x = Hora, y = Media, group = 1), color = &quot;purple&quot;) + labs(title = &quot;Média Horária Anual&quot;, y = &quot;NOx [ppb]&quot;) df_2014_weekly &lt;- df_2014 %&gt;% group_by(Hora, weekdays) %&gt;% #-- Agrupando os dados pelas colunas Hora e weekdays summarise(Media = mean(MediaHoraria, na.rm = T)) %&gt;% ungroup() %&gt;% mutate(Hora = as.POSIXct(strptime(Hora, &quot;%H:%M&quot;))) %&gt;% mutate(weekdays = factor(weekdays, levels = c(&quot;segunda&quot;, &quot;terça&quot;, &quot;quarta&quot;, &quot;quinta&quot;, &quot;sexta&quot;, &quot;sábado&quot;, &quot;domingo&quot;))) #-- Ordenando os dias da semana ggplot(df_2014_weekly) + scale_x_datetime(date_labels = &quot;%H:%M&quot;) + geom_col(aes(x = Hora, y = Media), fill = &quot;purple&quot;) + labs(title = &quot;Média Horária Anual por Dia da Semana&quot;, y = &quot;NOx [ppb]&quot;) + facet_wrap(~ weekdays) #-- Criando paineis em função do dia da semana df_2014_monthly &lt;- df_2014 %&gt;% group_by(Hora, mes) %&gt;% #-- Agrupando os dados pelas colunas Hora e mes summarise(Media = mean(MediaHoraria, na.rm = T)) %&gt;% ungroup() %&gt;% mutate(Hora = as.POSIXct(strptime(Hora, &quot;%H:%M&quot;))) %&gt;% mutate(mes = factor(mes, levels = c(&quot;janeiro&quot;, &quot;fevereiro&quot;, &quot;março&quot;, &quot;abril&quot;, &quot;maio&quot;, &quot;junho&quot;, &quot;julho&quot;, &quot;agosto&quot;, &quot;setembro&quot;, &quot;outubro&quot;, &quot;novembro&quot;, &quot;dezembro&quot;))) #-- Ordenando os meses ggplot(df_2014_monthly) + scale_x_datetime(date_labels = &quot;%H:%M&quot;) + geom_col(aes(x = Hora, y = Media), fill = &quot;purple&quot;) + labs(title = &quot;Média Horária Anual por Mes&quot;, y = &quot;NOx [ppb]&quot;) + facet_wrap(~ mes) #-- Criando paineis em função do mês Exercício: Em média, como os dados válidos de NOx variam mensalmente ao longo do ano de 2014? Faça um gráfico. Desafio: Ainda é possível melhorar os gráficos acima! Pesquise como: * Diminuir a quantidade de horários no eixo x * Separar por dias da semana e meses a partir da coluna “tempo”, não precisando usar as colunas de caracteres e consequentemente ordená-las manualmente 5.2.1 Explorando outras escalas de cores e temas Pacotes veinreport e cptcity devtools::install_github(&quot;atmoschem/veinreport&quot;) library(veinreport) library(cptcity) Refazendo alguns gráficos: ggplot(df, aes(x = tempo, y = MediaHoraria)) + geom_line(aes(color = MediaHoraria)) + labs(x = &quot;Data&quot;, y = &quot;NOx [ppb]&quot;) + scale_color_gradientn(colours = cpt()) + #-- Definindo as cores com uma escala gradiente theme_black() ## Warning in as.POSIXlt.POSIXct(x): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(to): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(x): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(to): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(from): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXct.POSIXlt(r1): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning in as.POSIXlt.POSIXct(x, tz): unknown timezone &#39;Americas/Sao_Paulo&#39; ## Warning: Removed 1 rows containing missing values (geom_path). Experimentando escalas de cores com a função lucky: ggplot(df_2014_monthly) + scale_x_datetime(date_labels = &quot;%H:%M&quot;) + geom_col(aes(x = Hora, y = Media, fill = Media)) + labs(title = &quot;Média Horária Anual por Mes&quot;, y = &quot;NOx [ppb]&quot;) + scale_fill_gradientn(colors = lucky()) + #-- Definindo as cores com uma escala gradiente aleatória theme_black() + theme(legend.position = &quot;bottom&quot;, legend.direction = &quot;horizontal&quot;) + #-- Colocando a legenda na parte de baixo da figura facet_wrap(~ mes) #-- Criando paineis em função do mês ## Colour gradient: jjg_cbac_div_cbacPiYG07, number: 3633 Este é só o começo! Veja aqui um pouco mais das muitas aplicações do ggplot. "],
["loop.html", "Capítulo 6 Estruturas de Controle 6.1 if-else 6.2 for 6.3 while 6.4 repeat 6.5 lapply 6.6 sapply 6.7 split 6.8 tapply 6.9 apply 6.10 mapply", " Capítulo 6 Estruturas de Controle Em breve. 6.1 if-else 6.2 for 6.3 while 6.4 repeat 6.5 lapply 6.6 sapply 6.7 split 6.8 tapply 6.9 apply 6.10 mapply "],
["fx.html", "Capítulo 7 De Scripts a Funções e de Funções a Pacotes", " Capítulo 7 De Scripts a Funções e de Funções a Pacotes Em breve. "],
["geo.html", "Capítulo 8 Geo Spatial: raster, sf e stars", " Capítulo 8 Geo Spatial: raster, sf e stars Em breve. "],
["referencias.html", "Referências", " Referências R Programming for Data Science (Leanpub) R Graphics Cookbook (Cookbook for R) An Introduction to R (CRAN) R Data Import/Export (CRAN) RStudio Cheat Sheets (RStudio) Webinars and Videos On Demand (RStudio) Online Learning (RStudio) Learn the tidyverse (Tidyverse) Writing R Extensions (CRAN) R Internals (CRAN) R Language Definition (CRAN) Quer fazer um documento com o mesmo estilo do nosso? Leia bookdown: Authoring Books and Technical Documents with R Markdown (bookdown.org) "]
]
